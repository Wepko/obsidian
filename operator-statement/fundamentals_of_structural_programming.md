## ОСНОВЫ СТРУКТУРНОГО ПРОГРАММИРОВАНИЯ.

 Метод нисходящего проектирования предполагает последовательное разложение (детализация) общей функции обработки данных на простые функциональные элементы "сверху-вниз". В результате строится иерархическая схема, отражающая состав и взаимоподчиненность отдельных функций, которая носит название функциональная структура алгоритма (ФСА) приложения. Степень датализации функций может быть различной, но иерархическая схема должна давать представление о составе и структуре взаимосвязанных функций и общем алгоритме обработки данных.

 Структурное программирование основано на модульной структуре программного продукта и типовых управляющих структурах алгоритмов обработки данных различных программных модулей.

 В любой типовой структуре блок, кроме условного, имеет только один вход и выход, безусловный переход на блок с нарушением иерархии запрещен (оператор типа GOTO в структурном программировании рекомендуется не использовать).

 Управляющие структуры алгоритмов:

-   Последовательность (следование). Следование включает фиксированный перечень блоков (операторов). Каждый очередной блок обрабатывается после завершения предыдущего без дополнительных условий. Для изменения порядка обработки блоков редактируется последовательность выполняемых блоков (операторов);
-   Альтернатива (ветвление). Всегда существует условие выбора альтернативы обработки. Каждая альтернатива выполняется только один раз; выполнение одной из двух альтернатив - обязательно. Развитием данного типа структуры является множественная альтернатива (множественное ветвление), когда последовательно проверяются условия выполнения определенных альтернатив. Если очередное условие истинно, обрабатывается соответствующая ему альтернатива, после чего происходит выход. В противном случае - переход к проверке условия следующей альтернативы. Если ни одно из условий не выполнялось, происходит выход.
-   Цикл (повторение). Всегда существует условие обработки тела цикла - конечной совокупности инструкций, повторяющейся определенное количество раз, описанное в условии. Если условие не выполняется, цикл прерывается и осуществляется выход. Условие может содержать счетчик повторений тела цикла либо выражение логического типа.


## 1. Простые операторы. Программирование алгоритмов линейной структуры

 Оператор - предписание в языке программирования, предназначенное для задания некоторого завершенного действия в процессе переработки информации на ПЭВМ.

 Основная часть программы на языке Паскаль представляет собой последовательность операторов, каждый из которых производит некоторое действие над данными. Операторы выполняются последовательно в том порядке, в котором они записаны в тексте программы. Разделителем операторов служит точка с запятой.

 Все операторы языка Паскаль подразделяются на три группы: простые, ввода-вывода и структурные. Фактически операторы ввода-вывода являются обращением к стандартным процедурам, так как в Паскале нет специальных операторов ввода-вывода. Однако по установившейся традиции такие обращения называют операторами.


![Логическая структура операторов языка программирования
Паскаль](http://allpasc.narod.ru/pascalbook/ii01-01.GIF)

Категория операторов:
1. Простые операторы
	1. Операторы присваивания
	2. Оператор перехода 
	3. Встроенные операторы (I/O)
	4. Оператор вызова процедур
	5. Пустрой оператор
2. Структурные операторы
	1. Составной оператор
	2. Оператор цикла
	3. Оператор with
	4. Условный оператор


## 1.1. Простые операторы.

 Операторы, не содержащие в себе никаких других операторов, называются простыми. К ним относятся операторы присваивания, безусловного перехода, вызов процедуры и пустой оператор.

##  1.1.1. Оператор присваивания.

 Оператор присваивания (:=) предписывает выполнить выражение, заданное в его правой части, и присвоить результат переменной, идентификатор которой расположен в левой части. Переменная и выражение должны иметь один и тот же тип. Исключение представляет случай, когда переменная имеет вещественный тип, а выражение - целочисленный. Допустимо присваивание любых типов данных, кроме файловых.  
  
Формат: имя_переменной := выражение;  
Пример: Sort := 1; Cost := 15.23;  
Name := 'Модель ВАЗ 2109';  
Result := sin(A) + cos(B);  
Y := Sqrt(X) + 1; L := M and N;

##  1.1.2. Оператор безусловного перехода (goto).

 Исполняемая часть программы является некоторым составным оператором, в котором составляющие его операторы выполняются в той последовательности, в которой они записаны. Если нужно изменить такую последовательность, пользуются оператором перехода. Оператор безусловного перехода (goto) означает "перейти к..." и применяется в случаях, когда после выполнения некоторого оператора надо выполнить не следующий по порядку, а какой-либо другой, отмеченный меткой оператор. Т.е. передать управление оператору, перед которым стоит метка, указанная в операторе goto.  
  
Формат: goto метка;  
Пример: ..........  
Label Metka1, Metka2;  
..........  
Metka1:  
goto Metka2;  
Metka2:  
goto Metka1;  
..........

 Метка представляет собой идентификатор или любое целое число без знака в диапазоне от 0 до 9999. Метка должна быть описана в разделе label и записывается перед помечаемым оператором, от которого отделяется двоеточием. Между меткой и данным можно включать один или несколько пробелов.  
  
Пример: goto D2;  
10:  
a := 2;  
............  
D2:  
Y := x / a;  
goto 10:

 При записи оператора goto необходимо отметить следующее:  
а) метка, на которую передается управление, должна быть описана в разделе описания меток того блока процедуры, функции основной программы, в котором эта метка используется;  
б) областью действия метки является тот блок, в котором она описана. Переход возможен только в пределах блока;  
в) попытка выйти за пределы блока или передать управление внутрь другого блока вызывает программное прерывание.

 Следует помнить, что в соответствии с правилами структурного программирования оператор goto следует применять как можно реже, т.к. считается, что его частое употребление резко усложняет понимание логики программы, усложняет ее отладку. В крайнем случае он может использоваться для преждевременного выхода из оператора повтора.  
  
Пример: Программа, реализующая оператор GoTo.  
Program GoTo;  
Uses CRT;  
Label Finish; { Описание метки }  
Var password : integer;  
Begin  
Finish:  
ClrScr;  
Write('Введите пароль: '); ReadLn(password);  
{ 999 - правильное значение пароля }  
if password <> 999 then  
begin  
WriteLn('Неверный пароль! Доступ запрещен!');  
goto Finish  
end  
else WriteLn('Пароль верный! Доступ разрешен!');  
ReadLn  
End.

##  1.1.3. Оператор вызова процедуры.

 Оператор вызова процедуры служит для активизации предварительно определенной пользователем или стандартной процедуры.  
  
Формат: Имя_процедуры (фактические_параметры);  
Пример:  
Program Primer;  
Procedure Vp1;  
begin  
....... {Тело процедуры Vp1}  
end;  
Procedure Vp2;  
begin  
...... {Тело процедуры Vp2}  
end;  
Begin  
Vp1; {Вызов процедуры Vp1}  
Vp2; {Вызов процедуры Vp2}  
End.

##  1.1.4. Пустой оператор.

 Пустой оператор не содержит никаких символов и не выполняет никаких действий. Он может быть расположен в любом месте программы, где синтаксис языка допускает наличие оператора. Как и все другие операторы, пустой оператор может быть помечен меткой. Чаще всего пустой оператор используется для организации выхода из середины программы или составного оператора:  
begin  
goto Metka; {Переход в конец блока}  
......  
Metka: {Пустой оператор помечен меткой}  
end.

 Пустому оператору соответствует символ ";" на том месте, где по правилам должен быть какой-либо оператор.  
  
Пример: A := B; ; M := 7.2;

##  1.1.5. Операторы ввода-вывода.

 В любом языке программирования предусмотрена возможность обмена или пересылки информации между ОЗУ (оперативным запоминающим устройством) и внешними устройствами (принтер, дисплей, дисководы и т.д.).

 Для ввода в ОЗУ (чтения) и вывода из ОЗУ (записи) данных в Турбо Паскале существуют стандартные (встроенные) процедуры ввода-вывода, вызываемые соответственно, операторами Read и Write.

 Ввод данных. Для организации процедуры чтения данных с клавиатуры в ОЗУ используются три оператора:

-   Read(список_переменных); - каждое вводимое значение последовательно присваивается переменным из списка; вводимые числа должны отделяться друг от друга при вводе пробелами или нажатием клавиши Enter;
-   ReadLn(список_переменных); - то же, что и оператор Read, только на экране после ввода данных происходит переход на новую строку (т.е. следующий оператор ввода будет вводить данные с новой строки); вводимые числа должны отделяться друг от друга при вводе пробелами или нажатием клавиши Enter;
-   ReadLn; - происходит переход на новую строку без ввода данных.

 Значения вводимых переменных должны соответствовать типам переменных из списка ввода. В Турбо Паскале допускается вводить значения следующих данных: целых (integer), вещественных (real), символьных (char), а также строковых переменных (string).

 С клавиатуры нельзя ввести:

-   значение логической переменной;
-   значение переменной типа "перечисление";
-   значение переменной типа "массив" (можно вводить значения отдельных элементов массива);
-   значение переменной типа "множество" (можно вводить значения отдельных элементов множества);
-   значение переменной типа "запись" (можно вводить значения отдельных полей записи);

Пример: Пусть имеются переменные следующих типов: R: real; C1, C2, C3: char, которым необходимо присвоить соответствующие значения: 1.5, 'M', 'N', 'K'. Для этого используется оператор Read(R, C1, C2, C3). При вводе значения переменных можно расположить следующим образом: 1.5MNK или 1.5E0MNK (без апострофов), но нельзя после 1.5 поместить пробел, т.к. он воспринимается как значение символьной константы.

 Вывод данных. Вывод данных обычно принимает форму, которая зависит от выходного устройства: на экран, на запоминающие устройства, в порты ввода/вывода. Для организации процедуры чтения данных из ОЗУ и записи на экран используются три оператора:

-   Write(список_переменных); - выводит последовательно значения переменных из списка;
-   WriteLn(список_переменных); - то же, что и оператор Write, но после вывода значений на экране осуществляется переход на новую строку (следующий оператор вывода будет выводить данные с начала новой строки);
-   WriteLn; - осуществляет переход на новую строку без вывода данных (вывод "пустой" строки).

 В Турбо Паскале допустим вывод значений следующих данных:

-   целых переменных (integer);
-   вещественных переменных (real);
-   символьных переменных (char);
-   логических переменных (boolean);
-   символьных констант;
-   арифметических и логических выражений;
-   строковых переменных.

 С помощью оператора вывода нельзя вывести:

-   значение переменной типа "перечисление";
-   значение переменной типа "массив" (можно выводить значения отдельных элементов массива);
-   значение переменной типа "множество" (можно выводить значения отдельных элементов множества);
-   значение переменной типа "запись" (можно выводить значения отдельных полей записи);

Пример: Пусть в результате выполнения программы переменные получили значения: I = -5, R = 3.52, C = '+', B = True. Выведем их на дисплей:  
program Pr;  
var I: integer; R: real;  
C: char; B: boolean;  
................  
Write('ПРИМЕР'); WriteLn;  
WriteLn(' I =',I,' R =',R);  
WriteLn(' Символ - ',C);  
Write(' B =',B);  
  
В результате выводимые значения будут такими:  
  
ПРИМЕР  
I =-5 R = 3.5200000000E+00  
Символ - +  
B =TRUE  

 В Турбо Паскале предусмотрен вывод данных в определенном пользователем форматом (форматированный вывод). В общем случае формат имеет следующий вид: P:M, где P - имя переменной, M - целая константа, указывающая на число позиций, необходимых для выводимой величины P (в качестве параметра M может указываться не число, а имя константы, описанное в разделе const).

 Для вещественных переменных формат может быть задан в таком виде: P:M:N (элемент : длина : количество цифр), где M - общее число позиций для выводимой переменной P, включая знак числа, целую часть, точку и дробную часть; N - число позиций дробной части. В этом случае переменная P выводится в виде константы с фиксированной точкой.  
  
Пример: Используем форматированный вывод переменных из предыдущего примера:  
..................  
WriteLn(' I =',I:3,' R =',R:5:2);  
WriteLn(' Символ - ',C:5);  
Write(' B =',B:8);  
  
Результат:  
I = -5 R = 3.52  
Символ - +  
B = TRUE

##  1.2. Примеры программ линейной структуры.

Пример: Осуществить вывод на принтер таблицы, в которой записаны значения сторон прямоугольника и его площадь.  
Program DemoWriteln;  
Uses CRT;  
Var { A, B - стороны, Area - площадь }  
A, B, Area : integer;  
Begin  
A := 8; B := 4;  
Area := A * B;  
{ Lst указывает, что вывод производится на принтер }  
WriteLn(Lst, '-----------------------------------');  
WriteLn(Lst, '| Сторона A | Сторона B | Площадь |');  
WriteLn(Lst, '-----------------------------------');  
WriteLn(Lst, '|', A:6, '|':6, B:6, '|':6, Area:6, '|':4);  
WriteLn(Lst, '-----------------------------------');  
End.  
  
В результате работы программы получим таблицу:  
----------------------------------------  
| Сторона A | Сторона B | Площадь |  
----------------------------------------  
|         8         |         4         |      32       |  
----------------------------------------  
каждая строка которой будет печататься с первой позиции новой строки печатающего устройства.  
  
Пример: Программа, пересчитывающая расстояние, выраженное в милях, в расстояние, выраженное в километрах.  
program MilToKm;  
uses CRT;  
var Mil : real; { Расстояние в милях }  
Km : real; { Расстояние в километрах }  
Begin  
ClrScr;  
Write('Задайте расстояние в милях: '); ReadLn(Mil);  
Km := Mil * 1.6;  
WriteLn(Mil:5:2, ' миль это ', Km:5:2, ' километров');  
ReadLn  
End.  
  
Примечание: Оператор ReadLn можно применить для задержки вывода результата работы программы на экране до нажатия на клавишу Enter.


## 2. Структурные операторы. Программирование ветвящихся и циклических структур.

 Структурные операторы представляют собой структуры, построенные из других операторов по строго определенным правилам. Все структурные операторы подразделяются на три группы: составные, условные и повтора.

##  2.1. Составной оператор.

 Составной оператор - это объединение нескольких операторов в одну группу. Общий вид этого оператора следующий:  
begin  
оператор_1;  
оператор_2;  
...........  
оператор_n  
end;

 В этой конструкции слова begin и end выполняют роль операторных скобок: открывающей и закрывающей.

 Составной оператор можно вставлять в любое место программы, где допускается использование одного оператора. В свою очередь любой из операторов составного оператора также может быть составным. Нельзя извне составного оператора передавать управление внутрь его (оператором goto).  
  
Пример:  
begin  
A := A * B + (N - D);  
Res := A + B * Pi;  
Writeln(Res:12:6)  
end;

 Составной оператор воспринимается как единое целое и может находиться в любом месте программы, где синтаксис языка допускает наличие оператора. Обычно составной оператор используется при написании условных операторов.

##  2.2. Оператор условного перехода (if...then...else).

 Условный оператор удобно применять, когда требуется выбрать одну из двух альтернатив. Условные операторы обеспечивают выполнение некоторого оператора, группы операторов или блока в зависимости от заданных условий. Паскаль допускает использование двух условных операторов: if и case.  
  
Общий вид оператора условного перехода:  
if <лог_выр> then <опер_1> [else <опер_2>];  
  
Здесь квадратные скобки означают, что конструкция else с <опер_2> может отсутствовать.  
Перед else точка с запятой не ставится. <Опер_1> или <опер_2> - это простые или составные операторы.  
<Лог_выр> - это выражение булевского типа. Оно может быть простым или сложным. Сложные условия образуются с помощью логических операций AND, OR, NOT. При записи условий могут использоваться все возможные операции отношения. Результат <лог_выр> всегда имеет булевский тип.  
Если <лог_выр> истинно, то выполняется <опер_1>, иначе - <опер_2> (или следующий за if оператор, если else отсутствует).  
В качестве <опер_1> или <опер_2> могут использоваться другие операторы if. В этом случае каждое else относится к ближайшему слева if, не имеющему else. Для удобства восприятия программы рекомендуется слово else писать под соответствующим ему словом then.  
  
Пример: Вычислить:

Y={

x+1, при x < 0

sin(x), при 0 <= x < 5

cos(x), при x >= 5

  
Фрагмент программы, описывающий эту алгебраическую конструкцию:  
....................  
if x < 0 then y := x +1;  
if (x >= 0) and (x < 5) then y := sin(x);  
if x >= 5 then y := cos(x);  
....................  
В этом примере наличие скобок в логических выражениях оператора if является обязательным, т.к. операции сравнения имеют более низкий приоритет, чем логические операции.

 В операторе if после then или else часто используется пустой или составной оператор.  
  
Пример:  
if a = 0 then  
{ применение пустого оператора }  
else y := x * a;  
if x1 < x2 then  
{ применение составного оператора }  
begin  
y := x2;  
x2 := x1;  
x1 := y  
end;  
  
Пример: Разберем программу с одним из вариантов вычисления выражения:

K={

15 * A2 + 21 * B2 при A > B,

15 * B2 + 21 * A2 при 1 < A <= B

  
где A = 2.34E+2 и B = 17.2  
program PR1;  
uses CRT;  
const A = 2.34E+2; B = 17.2;  
var K, K1, K2 : real;  
Begin  
ClrScr;  
K1 := Sqrt(15 * A * A + 21 * B * B);  
K2 := Sqrt(15 * B * B + 21 * A * A);  
if A > B then K := K1;  
if (1 < A) and (A <= B) then K := K2;  
if A <= 1 then Write('Результат неопределен')  
else Write(' K =', K:5:5);  
ReadLn  
End.  
  
Пример: Программа решения квадратного уравнения.  
program KvUr;  
uses CRT;  
var a, b, c : real; { коэффициенты уравнения }  
x1, x2 : real; { корни уравнения }  
d : real; { дискриминант }  
Begin { начало раздела операторов }  
ClrScr; { процедура очистки экрана }  
Write('Введите A: '); ReadLn(a);  
Write('Введите B: '); ReadLn(b);  
Write('Введите C: '); ReadLn(c);  
d := b * b - 4 * a * c; { вычисление дискриминанта }  
if d >= 0 then{ если D >= 0, то ... }  
begin  
x1 := (-b - SQRT(d)) / (2 * a);  
x2 := (-b + SQRT(d)) / (2 * a);  
WriteLn('Корни уравнения: ');  
WriteLn('x1 =', x1, ' x2=', x2);  
end  
else WriteLn('Корней нет');  
End. { конец раздела операторов }  
  
  
Пример: Программа нахождения большего из двух введенных чисел.  
program Numbers;  
uses CRT;  
var a, b : real;  
Begin { начало раздела операторов }  
ClrScr;  
Write('Введите два числа: '); ReadLn(a, b);  
{ если два числа равны, то ... }  
if a = b then WriteLn('Числа равны')  
else if a > b then { ... иначе, если a > b, то ... }  
WriteLn('Число A больше числа B')  
else WriteLn('Число B больше числа A')  
End. { конец раздела операторов }  
  
Пример: Программа для вычисления стоимости разговора по телефону. Предусмотрен запрос длительности разговора и дня недели, после чего происходит вычисление стоимости разговора. Если день недели суббота или воскресенье, то стоимость уменьшается на величину скидки. Цена минуты разговора и величина скидки приняты за постоянные величины 5 рублей за минуту разговора и 20% соответственно.  
Program Call;  
Uses CRT;  
Var Time : integer; { Длительность разговора }  
Day : integer; { День недели }  
SumCall : real; { Стоимость разговора }  
Begin  
ClrScr;  
Write('Длительность разговора (мин)'); ReadLn(Time);  
Write('День недели');  
Write('1 - понедельник, 2 - вторник, 3 - среда ...');  
ReadLn(Day);  
SumCall := 5 * Time;  
if (Day = 6) or (Day = 7) then SumCall := SumCall * 0.8;  
WriteLn('Стоимость разговора:', SumCall:8:2);  
ReadLn  
End.  
  

 Часто в программе необходимо реализовать выбор более чем из двух вариантов. Например, известно, что для каждого человека существует оптимальное значение веса (в кг), которое может быть вычислено по формуле: Рост(см) - 100. Очевидно, что реальный вес может быть меньше оптимального, равняться ему или превышать. Следующая программа вычисляет оптимальное значение веса, сравнивает его с реальным и выводит соответствующую рекомендацию.  
Program Optimum;  
Uses CRT;  
Var W : real; { Вес }  
H : real; { Рост }  
Opt : real; { Оптимальный вес }  
d : real; { Отклонение от оптимального веса }  
Begin  
ClrScr;  
Write('Ваш вес (кг)'); ReadLn(W);  
Write('Ваш рост (см)'); ReadLn(H);  
Opt := H - 100;  
if W = Opt then WriteLn('Вес оптимальный!')  
else if W < Opt then  
begin  
d := Opt - W;  
WriteLn('Нужно поправляться на ', d:5:2, ' кг');  
end  
else  
begin  
d := W - Opt;  
WriteLn('Нужно худеть на ', d:5:2, ' кг');  
end;  
ReadLn  
End.

##  2.3. Оператор множественного выбора (case).

 Оператор выбора case является обобщением оператора if и позволяет сделать выбор из конечного числа имеющихся альтернатив. Он состоит из выражения, называемого селектором, и списка констант выбора (список может состоять и из одной константы). Как и в операторе if, здесь может присутствовать слово else, имеющее тот же смысл. Его общий вид следующий:  
  
case <выражение_селектор> of  
список_констант_1: оператор_1;  
список_констант_2: оператор_2;  
..............................  
список_констант_n: оператор_n  
else  
оператор  
end;

 Здесь значения <выражение_селектор> и констант должны быть одного и того же скалярного типа (кроме real), т.е. integer, boolean, char, ограниченного типа или иметь тип "перечисление".

 Оператор case работает следующим образом. Сначала вычисляется значение <выражение-селектор>, затем обеспечивается реализация того оператора, константа выбора которого равна текущему значению селектора. Если ни одна из констант не равна текущему значению селектора, выполняется оператор, стоящий за словом else. Если слово else отсутствует, активизируется оператор, находящийся за словом end, т.е. первый оператор за границей case.

 Ниже приведены типичные формы записи оператора CASE. Селектор интервального типа:  
case I of  
1..10 : Writeln('Число ', I:4, ' в диапазоне 1 - 10');  
11..20 : Writeln('Число ', I:4, ' в диапазоне 11 - 20');  
21..30 : Writeln('Число ', I:4, ' в диапазоне 21 - 30')  
else Writeln('Число ', I:4, ' вне предела контроля')  
end;  
  
Селектор целочисленного типа:  
case K of  
1 : Z := K + 10;  
2 : Z := K + 100;  
3 : Z := K + 1000  
end;  
  
case I + 1 of  
2 : x := 0;  
100, 3 : x := x * x;  
4 : x := Sin(x)  
end;

 Например, если значение I + 1 есть 100 или 3, то выполняется оператор x * x и т.д.  
ПРИМЕЧАНИЕ: Метки оператора CASE не описываются в разделе меток (label), и на них нельзя переходить оператором goto.  
  
Селектор перечисляемого типа:  
var Season: (Winter, Spring, Summer, Autumn);  
Begin  
......  
case Season of  
Winter: Writeln('Зима');  
Spring: Writeln('Весна');  
Summer: Writeln('Лето');  
Autumn: Writeln('Осень')  
end;  
  
Пример: Программа, с помощью которой инициируется нажатие клавиши на клавиатуре.  
program prg;  
uses CRT;  
var I : char;  
Begin  
ClrScr;  
Write('Введите символ с клавиатуры'); ReadLn(I);  
case I of  
'A'..'Z':Write('Прописная буква латинского алфавита',I);  
'a'..'z':Write('Строчная буква латинского алфавита',I);  
'0'..'9':Write('Введена цифра',I);  
'А'..'Я':Write('Прописная буква русского алфавита',I);  
'а'..'я':Write('Строчная буква русского алфавита',I)  
else Write('Введен символ - ',I)  
end;  
ReadLn  
End.  
  
Пример программы с селектором логического типа. Вычислить значение функции:

Y{

Sin(X), если X < 0

Sqrt(X), если X >= 0

  
program DemoCase;  
uses CRT;  
var X, Y: real;  
Begin  
ClrScr;  
Write('Введите любое число: '); ReadLn(X);  
case X < 0 of  
True : Y := sin(X);  
False : Y := sqrt(X);  
end;  
Writeln('Значение функции равно: ', Y:5:2);  
ReadLn  
End.



## 2.4. Операторы повтора (цикла).

 При решении многих задач некоторую последовательность действий приходится выполнять несколько раз. Например, чтобы найти фамилию ученика в списке, надо проверить первую фамилию списка, затем вторую, третью и т.д. до тех пор, пока не будет найдена нужная или не будет достигнут конец списка. Такие повторяющиеся действия называются циклами и реализуются в программе с использованием инструкций циклов.

 В Турбо Паскале различают три вида операторов организации циклов:

-   while - оператор цикла с предварительным условием (цикл с предусловием);
-   repeat - оператор цикла с последующим условием (цикл с постусловием);
-   for - оператор цикла с управляющим параметром (цикл с параметром).

##  2.4.1. Оператор цикла while.

 Цикл с предусловием характерен тем, что перед выполнением цикла всегда необходимо проверить условие. Если условие истинно, то цикл продолжается, иначе - цикл заканчивается.  
  
Общий вид оператора следующий:  
while <логическое_выражение> do <оператор>;  
где <оператор> - простой или составной оператор, а <логическое_выражение> - выражение булевского типа.

 Оператор цикла while действует следующим образом. Предварительно проверяется значение логического выражения. Пока оно истинно, выполняется оператор циклической части (после do). Как только значение логического выражения становится ложным, происходит выход из цикла.

 Если с самого начала значение логического выражения ложно, то оператор циклической части не выполняется ни разу. Если логическое выражение никогда не принимает значение False (ложно), то цикл будет выполняться бесконечно долго.  
  
Пример: Вычислить значение выражения A**7 при любом значении A (например, при A < 0, когда выражение Exp(7 * Ln(A)) недопустимо).  
program prg;  
uses СRT;  
var I : integer; A, P : real;  
Begin  
ClrScr;  
I := 1; P := 1;  
Write('Введите основание степени: '); ReadLn(A);  
while I <= 7 do  
begin  
P := P * A;  
I := I + 1 { Можно использовать функцию Inc(I) }  
end;  
Write('Значение выражения A**7 равно ', P:5:10);  
ReadLn  
End.  
  
Пример: Программа для вычисления и вывода на дисплей таблицы значений функции Y = a * X * X при X = 5, 6, 7,..., 35; a = 10.2 с помощью цикла while.  
program prg;  
uses CRT;  
var Y, a : real; X : integer;  
Begin  
ClrScr;  
X := 5; a := 10.2;  
while X <= 35 do  
begin  
Y := a * X * X;  
WriteLn(' X =', X,' Y =', Y:5:3);  
Inc(X)  
end;  
ReadLn  
End.

 В ряде случаев цикл изначально предполагается как бесконечный. Тогда в условии записывается константа True или очевидный факт, который в любой ситуации возвращает значение True. Второй вариант менее предпочтителен.  
  
Пример: while True do write('Бесконечный цикл');  
while 5 = 5 do write('Бесконечный цикл');  
{ Очевидно, что результат 5 = 5 всегда равен True }

##  2.4.2. Оператор цикла repeat.

 Оператор повтора repeat состоит из заголовка (repeat), тела цикла и условия окончания (until). Цикл с постусловием характерен тем, что вначале обязательно выполняются хотя бы один раз команды, составляющие тело цикла.

 После выполнения операторов циклической части проверяется условие. Если условие ложно, то вновь выполняются операторы циклической части. Если условие истинно, то цикл заканчивается.  
Общий вид оператора следующий:  
repeat  
<оператор_1>;  
<оператор_2>;  
...........  
<оператор_n>  
until <логическое_выражение>;

 <Логическое_выражение> (условие) - выражение булевского типа. При написании условия допустимы булевские операции и операции отношения. Операторы, заключенные между словами repeat и until, являются телом цикла.

 Оператор цикла repeat действует следующим образом:

-   выполняются операторы циклической части, проверяется значение логического выражения: если оно ложно, то вновь выполняются операторы циклической части; если же оно истинно, то цикл заканчивается;
-   если значение логического выражения истинно с самого начала, то операторы циклической части выполняются один раз. Если же логическое выражение никогда не принимает значение "истинно", то операторы циклической части выполняются бесконечное число раз, т.е. происходит "зацикливание";
-   нижняя граница операторов циклической части четко обозначена словом until, поэтому нет необходимости заключать эти операторы в операторные скобки begin - end. В то же время дополнительное наличие операторных скобок не является ошибкой.

  
  
Пример: В приведенном фрагменте программы описано вычисление A**7 с использованием цикла repeat:  
..............  
I := 1; P := 1;  
repeat  
P := P * A; Inc(I)  
until I > 7;  
..............  
  
Пример: Программа нахождения простых чисел. Как известно, число называется простым, если оно делится только на единицу и себя. Проверить, является ли число N простым, можно делением на 2, на 3 и т.д. до N и проверкой остатка после каждого деления. Если остаток равен 0, то следовательно найдено число, на которое N делится без остатка. Сравнив N и полученное таким образом число, можно определить, является ли N простым.  
program ProstoeChislo;  
uses CRT;  
var N, d, r : integer;  
Begin  
ClrScr;  
Write('Введите целое число: '); ReadLn(N);  
d := 2; { сначала делим на 2 }  
repeat  
r := N mod d; { вычисление остатка от деления }  
{ если N не разделилось нацело на d }  
if r <> 0 then d := d + 1;  
until r = 0; { выполнять, пока не нашли число, на которое  
делится N }  
{ если число N равно d, то ... }  
if d = N then WriteLn(N, '- простое число')  
else WriteLn(N, '- не является простым числом');  
repeat until KeyPressed  
End.  
  
Примечание: Оператор repeat until KeyPressed (исполняется "пустой" цикл до тех пор, пока не будет нажата любая клавиша) служит для задержки результата выполнения программы до нажатия на любую клавишу.

 Для преждевременного выхода из цикла можно использовать оператор goto (хотя в большинстве случаев можно обойтись и без него, присвоив параметру цикла выходящее за допустимый диапазон значение):  
.....................  
repeat  
S := 200 / A; S1 := A / S;  
if S < 0.5 then goto Metka;  
A := A + 1  
until (A <= 100) and (S1 <> 0);  
Metka:  
.....................  
  
Пример: Программа нахождения суммы четных чисел в интервале от 0 до 50 включительно  
program SumChetChisel;  
uses CRT;  
var I, Sum : integer;  
Begin  
I := 0; Sum := 0;  
repeat  
Sum := Sum + I; I := I + 2  
until I > 50;  
WriteLn('Сумма четных чисел равна: ', Sum)  
End.

##  2.4.3. Оператор цикла for.

 Цикл с параметром характерен тем, что количество исполняемых циклов определено в заголовке цикла при записи оператора for.  
  
Общий вид оператора: for I := N1 to N2 do <оператор>;  
где I - переменная (параметр) цикла; N1, N2 - начальное и конечное значения переменной цикла.

 В качестве переменной I может использовать только простую переменную, а в качестве N1, N2 могут использоваться выражения (за исключением вещественного типа real).

 Параметры I, N1, N2 должны быть одного и того же скалярного типа, но не real (т.е. целого, символьного, ограниченного типа или типа "перечисление"). Переменная цикла I принимает последовательные значения данного типа от N1 до N2. Если I, N1, N2 - целого типа, то в этом случае шаг изменения переменной цикла всегда равен +1.  
  
Пример:  
program Pr6;  
const A = 10.2;  
var X : integer;  
Begin  
for X := 5 to 35 do Writeln('Y=', A * X * X)  
End.

 Пример цикла, когда параметр принимает значения символьного типа: for I = 'A' to 'W' do Write(' ', I). В примере осуществляется печать букв латинского алфавита от A до W.

 Пример цикла, когда параметр принимает значения типа "перечисление".  
Пусть переменная D типа Day = (Pn, Vt, Sr, Ch, Pt, Sb, Vs):  
........................................  
type Day = (Pn, Vt, Sr, Ch, Pt, Sb, Vs);  
var  
D: Day; V: Day;  
........................................  
Тогда можно записать следующий оператор for:  
for D := Pn to Vs do  
begin  
..............  
if V > D then exit;  
..............  
end;

 Если необходимо записать цикл по убывающим значениям параметра I от N1 до N2, то используется следующий оператор:  
  
for I := N2 downto N1 do <оператор>;  
  
В этом случае параметр I принимает последовательные убывающие значения данного типа от N2 до N1.  
  
Пример: for I := 20 downto 1 do S := S + 1;  
Здесь I изменяется от 20 до 1 с шагом -1.  
  
Пример: Программа вычисления суммы при m = 8:

V=

 

 

 

m

mk/2

< tr>

Σ

---

< tr>

k=1

2(m-1)

 

program prg;  
uses CRT;  
var m, k : integer; V : real;  
Begin  
ClrScr;  
m := 8; V := 1.0;  
for k := 1 to m do  
V := V * Sqrt(Exp(k / 2 * Ln(m))) / (2 * (m - 1));  
Write('V=', V:5:8)  
repeat until KeyPressed  
End.  

 Для выхода из цикла до момента достижения параметром цикла конечного значения можно воспользоваться оператором goto:  
......  
for I := 1 to 45 do  
begin  
F := F + 1;  
if (F > 100) or (I = 30) then goto 100  
end;  
100:  
......

 Однако с точки зрения структурного программирования такой путь не является правильным. В связи с этим во всех случаях, где возможен преждевременный выход из цикла, следует применять описанные выше операторы while и repeat.

 В теле оператора for могут находиться другие операторы for. Это позволяет строить циклы, содержащие внутренние циклы. Такие внутренние циклы называются вложенными, например:  
for I := 1 to 10 do  
for J := 1 to 5 do Array[I, J] := 0;  
  
Пример: Вычислить сумму 5-ти первых элементов ряда 1 + 1/2 + 1/3 + ... (значение i-го элемента ряда связано с его номером формулой 1/i). После вычисления очередного элемента ряда выводится номер элемента и его значение.  
program Summa;  
uses CRT;  
var i : integer; { номер элемента ряда }  
elem : real; { значение элемента ряда }  
sum : real; { сумма элементов ряда }  
Begin  
ClrScr;  
sum := 0;  
for i := 1 to 5 do  
begin  
elem := 1/i;  
sum := sum + elem;  
WriteLn(i:2, ' ', elem:4:2);  
end;  
WriteLn('Сумма элементов ряда: ', sum:4:2);  
ReadLn  
End.  
  
Пример: Вычисление числа π с задаваемой с клавиатуры точностью. Вычисление значения π основано на том, что сумма ряда чисел 1 - 1/3 + 1/5 - 1/7 +1/9 +... приближается к значению π * 4 при достаточно большом количестве членов ряда. Член ряда вычисляется по формуле 1/(2 * n - 1) и умножается на -1, если n четное. Вычисление заканчивается когда значение очередного члена ряда становится меньше, чем заданная точность вычисления. Переменные: Pi - вычисляемое значение, e - точность вычислений, elem - значение члена ряда, n - номер члена ряда.  
Program ChisloPi;  
Uses CRT;  
Var Pi, E, elem : real; n : integer;  
Begin  
ClrScr;  
Pi := 0; n := 1; elem := 1; { Начальные значения }  
Write('Точность вычисления Pi: '); ReadLn(E);  
WriteLn('Вычисление Pi с точностью ', E:9:8);  
while elem >= E do  
begin  
elem := 1 / (2 * n - 1);  
{ Проверка остатка от деления n на 2 }  
if (n MOD 2) = 0 then Pi := Pi - elem  
else Pi := Pi + elem;  
Inc(n);  
end;  
Pi := Pi * 4;  
WriteLn('Значение Pi с точностью ',E:9:8,' равно',Pi:12:8);  
WriteLn('Просуммировано ',n,' членов ряда');  
ReadLn  
End.