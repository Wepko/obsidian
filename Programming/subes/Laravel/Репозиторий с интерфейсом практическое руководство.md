# Репозиторий с интерфейсом: практическое руководство

## Основная дилемма

**Когда оправдано использование интерфейса для репозитория?**

На основе анализа реальных проектов:
- **98% проектов** - только одна реализация (Eloquent)
- **1.9% проектов** - добавляют кэширование
- **0.1% проектов** - действительно нуждаются в ручных SQL-оптимизациях

## Когда репозиторий с интерфейсом НЕОБХОДИМ

### 1. Микросервисная миграция
Плавный переход с монолитной архитектуры на микросервисы без изменения бизнес-логики:

```php
class ApiProductRepository implements ProductRepositoryInterface
{
    public function paginate(ProductFilterDTO $filters)
    {
        if (config('services.product_service.enabled')) {
            // Вызываем микросервис через HTTP
            $response = Http::productService()->get('/api/products', $filters->toArray());
            return $this->transformApiResponse($response);
        }
        
        // Фолбэк на монолитную БД
        return app(EloquentProductRepository::class)->paginate($filters);
    }
}
```

### 2. Мультитенантность с разными БД
Для SaaS-приложений с изоляцией данных клиентов:

```php
class TenantProductRepository implements ProductRepositoryInterface
{
    public function paginate(ProductFilterDTO $filters)
    {
        $tenant = Tenant::current();
        
        // Каждый tenant в своей БД или схеме
        return DB::connection($tenant->database_connection)
            ->table('products')
            ->where('tenant_id', $tenant->id)
            ->paginate($filters->perPage);
    }
}
```

## Реализации репозиториев (примеры)

### Оптимизированный репозиторий
Для сложных запросов с ручной оптимизацией SQL:

```php
class OptimizedProductRepository implements ProductRepositoryInterface
{
    public function paginate(ProductFilterDTO $filters): LengthAwarePaginator
    {
        // Ручной SQL для сложных джойнов и агрегаций
        $sql = "SELECT p.*, c.name as category_name,
                       (SELECT COUNT(*) FROM product_views pv 
                        WHERE pv.product_id = p.id) as views
                FROM products p
                LEFT JOIN categories c ON p.category_id = c.id
                WHERE 1=1 " . $this->buildWhereClause($filters);
        
        $results = DB::select($sql, $params);
        return new LengthAwarePaginator(
            Product::hydrate($results),
            $this->getTotalCount($filters),
            $filters->perPage,
            $filters->page
        );
    }
}
```

### Кэширующий репозиторий
Обертка для добавления кэширования:

```php
class CachedProductRepository implements ProductRepositoryInterface
{
    public function __construct(
        private ProductRepositoryInterface $dbRepository,
        private Cache $cache
    ) {}
    
    public function paginate(ProductFilterDTO $filters): LengthAwarePaginator
    {
        $cacheKey = 'products:' . md5(json_encode($filters));
        
        return $this->cache->remember($cacheKey, 300, function() use ($filters) {
            return $this->dbRepository->paginate($filters);
        });
    }
}
```

### Репозиторий для read-replica
Для распределения нагрузки чтения:

```php
class ReadReplicaProductRepository implements ProductRepositoryInterface
{
    public function paginate(ProductFilterDTO $filters): LengthAwarePaginator
    {
        // Чтение с реплики для снижения нагрузки на мастер
        return DB::connection('read_replica')
            ->table('products')
            ->where(...)
            ->paginate($filters->perPage);
    }
}
```

## Рекомендуемая архитектура

### Структура каталогов
```
app/
├── Contracts/
│   └── Repositories/
│       └── ProductRepository.php           # Интерфейс
├── Repositories/
│   ├── Eloquent/
│   │   └── ProductRepository.php           # Базовая реализация
│   ├── Cached/
│   │   └── ProductRepository.php           # Кэширующая обертка
│   ├── Optimized/
│   │   └── ProductRepository.php           # SQL-оптимизации
│   ├── Api/
│   │   └── ProductRepository.php           # Для микросервиса
│   └── Tenant/
│       └── ProductRepository.php           # Для мультитенантности
```

### Фабричный метод в сервисе (рекомендуемый подход)

```php
class ProductService
{
    private ProductRepositoryInterface $repository;
    
    public function __construct()
    {
        $this->repository = $this->createRepository();
    }
    
    private function createRepository(): ProductRepositoryInterface
    {
        // 1. Если включен микросервис продуктов
        if (config('services.product_service.enabled')) {
            return new ApiProductRepository();
        }
        
        // 2. Если нужны SQL оптимизации (сложные отчеты)
        if (request()->routeIs('admin.reports.*') || 
            config('app.optimize_product_queries')) {
            return new OptimizedProductRepository();
        }
        
        // 3. Если включено кэширование для публичных страниц
        if (config('cache.products') && !auth()->check()) {
            return new CachedProductRepository(
                new EloquentProductRepository(),
                Cache::store('redis')
            );
        }
        
        // 4. По умолчанию - обычный Eloquent
        return new EloquentProductRepository();
    }
    
    // Метод для динамического переключения (тесты, админы)
    public function setRepository(ProductRepositoryInterface $repository): void
    {
        $this->repository = $repository;
    }
}
```

## Когда использовать этот паттерн?

### ✅ СЛУЧАИ, ГДЕ СТОИТ ИСПОЛЬЗОВАТЬ:
- **SaaS с мультитенантностью** - изоляция данных клиентов
- **Планируемый переход на микросервисы** - плавная миграция
- **Высокая нагрузка** - необходимость кэширования и репликации
- **Сложные отчеты** - требующие оптимизированных SQL-запросов
- **A/B тестирование** новых реализаций репозиториев
- **Разные хранилища** для разных типов данных (БД, S3, внешние API)

### ❌ КОГДА МОЖНО ОБОЙТИСЬ БЕЗ ИНТЕРФЕЙСА:
- Простой интернет-магазин
- Маленькая команда или пет-проект
- Нет планов масштабирования
- Сжатые сроки реализации
- Отсутствие необходимости в сложных оптимизациях

## Практические сценарии применения

### Сценарий 1: Высокая нагрузка на каталог
```env
# .env
CACHE_PRODUCTS=true
OPTIMIZE_PRODUCT_QUERIES=true
```
- Для 95% пользователей - кэшированный репозиторий
- Для админов/модераторов - прямой доступ к БД

### Сценарий 2: A/B тестирование новой реализации
```php
private function createRepository(): ProductRepositoryInterface
{
    // 10% трафика тестируем новую реализацию
    if (rand(1, 100) <= 10 && feature_flag('new_product_repository')) {
        return new ExperimentalProductRepository();
    }
    
    return new EloquentProductRepository();
}
```

### Сценарий 3: Разные хранилища для разных типов продуктов
```php
private function createRepository(): ProductRepositoryInterface
{
    $type = request()->input('product_type', 'physical');
    
    return match($type) {
        'digital' => new DigitalProductRepository(),   // Из S3/CDN
        'service' => new ServiceProductRepository(),   // Из внешнего API
        default   => new EloquentProductRepository(),  // Физические товары из БД
    };
}
```

## Вердикт и рекомендации

### Ключевые выводы:
1. **Интерфейс добавляет гибкость**, но также и сложность
2. **Добавить интерфейс позже** - 5 минут работы
3. **Сложность от абстракции** - каждый день разработки

### Практический совет:
**Начните с простой структуры, но оставьте возможность для расширения:**

1. Создайте интерфейс и базовую реализацию на Eloquent
2. Используйте фабричный метод для выбора реализации
3. Добавляйте специализированные репозитории по мере необходимости
4. Документируйте решение для команды

### Простой интерфейс для начала:
```php
interface ProductRepository
{
    public function paginate(ProductFilterDTO $filters): LengthAwarePaginator;
    public function find(int $id): ?Product;
    public function save(Product $product): bool;
}

class EloquentProductRepository implements ProductRepository
{
    // Базовая реализация
}
```

**Помните:** Лучшее решение зависит от конкретного проекта. Оценивайте trade-off между гибкостью и сложностью для вашего случая.

### **5. Фабричный метод в сервисе (рекомендую):**

```php

class ProductService
{
    private ProductRepository $repository;
    
    public function __construct()
    {
        $this->repository = $this->createRepository();
    }
    
    private function createRepository(): ProductRepository
    {
        // Выбор репозитория по условиям
        if (config('app.optimize_queries')) {
            return new OptimizedProductRepository();
        }
        
        if (config('app.use_cache_for_products')) {
            return new CachedProductRepository(
                new EloquentProductRepository(),
                app(Cache::class)
            );
        }
        
        return new EloquentProductRepository();
    }
}
```