
# Конспект лекции: Кодирование целых чисел (беззнаковые и знаковые)

## Краткое резюме
Лекция посвящена углублению в теорию кодирования, объяснению того, как компьютер представляют целые числа, и разбору ключевых проблем, которые возникают при переходе от беззнаковых к знаковым числам. Основной фокус — на логической связи между понятиями прямого и дополнительного кода, переполнением и практической проверке с помощью калькулятора.

---

###  Введение и постановка проблемы базового кодирования

Лектор начинает с напоминания фундаментального принципа: компьютеры оперируют только **двоичными сигналами** (0 и 1), которые представляются уровнями напряжения. При этом между логическими уровнями (примерно 0-0.5 В для "0" и ~3-5 В для "1") существует **зона неопределенности**.

**Почему зона неопределенности «не существует»?**
С точки зрения схемотехники, реализована примитивная, но надежная логика: **ток либо есть (логическая "1"), либо его нет (логическая "0")**. Промежуточное состояние (например, 2.5 В) практически невозможно, так как оно указывает на серьезный аппаратный сбой (например, воздействие сильных электромагнитных полей или проблемы с питанием), который обычно приводит к физическому повреждению схемы. **Следовательно**, для корректной работы компьютерной техники существует только два стабильных состояния, что исключает "третий путь" на уровне базовой логики.

---

###  Напоминание: емкость кодирования и позиционная система

**Переходя к основам кодирования**, лектор напоминает простое правило: количество уникальных чисел, которые можно закодировать, определяется формулой **2ⁿ**, где **n** — количество выделенных бит.
*   **Пример:** 1 байт = 8 бит → 2⁸ = 256 различных чисел.
*   **Важно:** В позиционной двоичной системе есть младший разряд (бит 0) и старший разряд (например, бит 7 для 1-байтового числа).

**Логика работы с беззнаковыми (неотрицательными) числами** в двоичной системе (0, 1, 10, 11...) **ровно такая же**, как и в привычной десятичной. Просто происходит последовательное увеличение на 1. Максимальное число в заданной разрядной сетке — это все единицы (например, 11111111 для одного байта). Его значение легко вычислить: **2ⁿ – 1** (например, 2⁸ – 1 = 255). Такое естественное кодирование называется **прямым кодом**.

---

### Проблема кодирования отрицательных чисел и неудачная попытка

**Однако числа бывают не только положительными.** Возникает вопрос: как в той же разрядной сетке (например, в одном байте) закодировать и отрицательные значения, если у нас все те же 256 комбинаций?

**Первая интуитивная (и ошибочная) идея:** Выделить **старший бит под знак** (0 — "+", 1 — "—"), а остальные биты оставить под значение (модуль) числа в прямом коде.
*   **Пример:** +3 = 0...00011, а -3 = 1...00011.

**В чем проблема этой схемы?** **Логика лектора строится на проверке арифметики** — основного, для чего нужны числа в компьютере.
1.  **Сложение не работает:** Если сложить коды +1 (0...0001) и -1 (1...0001) по правилам двоичной арифметики, получится -2 (1...0010), а не ноль.
2.  **Появление двух нулей:** Возникают два разных кода для нуля: "+0" (0...0000) и "-0" (1...0000). Для компьютера это две разные сущности, что неверно с математической точки зрения и крайне усложняет проектирование процессорной арифметики.

**Таким образом**, несмотря на кажущуюся простоту, эта схема непригодна. Этот пример подводит слушателя к выводу, что **теория кодирования — сложная и необходимая наука**, а не абстракция.

---

###  Ключевой мост: понятие переполнения как основа для решения

**Чтобы найти правильный способ кодирования, нужно вспомнить явление переполнения**, характерное для любой позиционной системы с ограниченной разрядной сеткой.
*   **Переполнение сверху:** При достижении максимума (например, 255 = 11111111) и добавлении 1 происходит "закольцовывание" — результат становится 0 (00000000).
*   **Переполнение снизу:** Аналогично, при вычитании 1 из 0 (00000000) мы получаем максимум (11111111).

**Лектор делает важнейший логический переход:** Давайте посмотрим на операцию **0 – 1**. С одной стороны, мы продемонстрировали переполнение снизу и получили 11111111. С другой стороны, **математически 0 – 1 = -1**. **Следовательно, код 11111111 можно интерпретировать как -1!** Это и есть отправная точка для корректного кодирования.

**Практический метод:** Чтобы получить код отрицательного числа, можно просто **вычесть его модуль из нуля** в рамках заданной разрядной сетки.

---

###  Дополнительный код: алгоритм и свойства

Описанная выше логика приводит нас к стандартному способу кодирования знаковых целых чисел — **дополнительному коду**. Его можно получить в три шага:
1.  Взять прямой код **модуля** числа.
2.  **Инвертировать** все биты (заменить 0 на 1, 1 на 0). Полученное значение называется **обратным кодом**.
3.  К результату **прибавить 1**.

**Каковы свойства дополнительного кода?**
*   **Старший бит — знаковый:** Для всех отрицательных чисел старший бит равен 1, для неотрицательных (0 и положительных) — 0.
*   **Арифметика работает:** Сложение кодов +1 и -1 теперь дает корректный 0.
*   **Один ноль:** Существует единственное представление нуля (все биты 0).
*   **Диапазон несимметричен:** Для одного байта диапазон от **-128 до 127**. Отрицательных чисел на одно больше, чем положительных (из-за того, что ноль занимает одно место в положительной части).
*   **Совпадение для положительных чисел:** Коды чисел от 0 до 127 в прямом и дополнительном коде **совпадают**. Это позволяет использовать единую арифметику.

**Важный вывод:** Прямой и дополнительный код — это **две разные схемы интерпретации** одних и тех же битовых последовательностей. Число 10000000 в беззнаковом коде — это 128, а в знаковом (дополнительном) — это -128.

---

###  Практическая проверка и работа с калькулятором

**Переходя к практической части**, лектор предлагает закрепить теорию с помощью **калькулятора программиста** (например, в Windows).
1.  **Режимы:** Калькулятор позволяет переключаться между системами счисления (Dec, Bin, Hex, Oct) и **задавать размерность числа** (Byte, Word, DWord, QWord).
2.  **Проверка теории:** Можно ввести число в десятичном виде и посмотреть его двоичное представление, убедившись, что -1 отображается как 11111111, а -128 — как 10000000.
3.  **Предостережение:** Не все калькуляторы корректно работают с очень большими числами из-за внутренних ошибок реализации. Калькулятор Windows в этом отношении надежен.
4.  **Особенность интерфейса:** При выбранном типе "Byte" и знаковом режиме ввод числа 255 может быть заблокирован, так как максимальное положительное число в байте — 127. Это наглядная демонстрация различия интерпретаций.

---

### Ключевые логические переходы лектора:
1.  **От базового принципа двоичной логики (есть ток/нет тока) → к объяснению устойчивости двоичных сигналов и невозможности промежуточных состояний.**
2.  **От простого кодирования беззнаковых чисел в прямом коде → к постановке проблемы: как в той же сетке представить отрицательные числа?**
3.  **От демонстрации интуитивно понятной, но ошибочной схемы "знак+модуль" → к выявлению ее фатальных недостатков через проверку арифметики (сложение не дает ноль, два нуля).**
4.  **От повторения концепции переполнения в замкнутой разрядной сетке → к ключевому озарению: результат "0 - 1" (переполнение) математически равен "-1", что дает основу для нового кода.**
5.  **От идеи "вычитания из нуля" → к формальному алгоритму получения дополнительного кода и анализу его свойств (работающая арифметика, один ноль, несимметричный диапазон).**
6.  **От теории → к практической верификации с помощью инструмента (калькулятора программиста), закрепляя понимание различий в интерпретации битовых паттернов.**