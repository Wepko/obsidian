Отлично! Я создам подробный структурированный конспект лекции Александра Вергуна с фокусом на практическое применение для составления заданий.

---

## **КОНСПЕКТ ЛЕКЦИИ №2: Кодирование целых чисел. Беззнаковые и знаковые числа.**

### **Блок 1: Физическая основа (0 и 1 на уровне "железа")**

**Вопросы для самопроверки:**
*   Каким физическим явлением представлены 0 и 1 в компьютере?
*   Почему в цифровой схеме невозможны промежуточные напряжения (например, 2.5В)?
*   Что происходит, если в схеме все-таки появляется напряжение в "запретной зоне"?

**Что я изучил:**
*   **Логический 0 (низкий уровень):** низкое напряжение (обычно 0-0.5В).
*   **Логическая 1 (высокий уровень):** высокое напряжение (например, 3.3В или 5В, "гуляет").
*   **Запретная зона неопределенности** между этими уровнями.
*   Принцип **"либо есть, либо нет"**. Схемотехника сделана так, что сигнал может быть только в одном из двух устойчивых состояний. Попадание в промежуточную зону говорит о серьезном сбое: неисправности железа, внешних сильных помехах или проблемах с питанием, что обычно ведет к выходу техники из строя.

**Краткие вопросы:**
1.  Почему компьютер не может обработать значение "полтора" на уровне одного бита?
2.  Какова основная причина существования только двух четко различимых логических уровней?

---

### **Блок 2: Формула емкости. Напоминание о базовых вычислениях**

**Вопросы для самопроверки:**
*   Как быстро вычислить, сколько уникальных чисел можно закодировать в N битах?
*   Что такое младший и старший разряд в бинарном числе?
*   Что означает фраза "старший разряд для двухбайтного числа — это 15-й бит"?

**Что я изучил:**
*   **Основная формула:** **K = 2^N**, где N — количество бит, K — количество уникальных чисел (комбинаций).
*   Например, в 1 байте (8 бит) можно закодировать **2⁸ = 256** уникальных чисел.
*   **Младший разряд (LSB) = 0-й бит.** Это самый правый бит, имеющий наименьший вес.
*   **Старший разряд (MSB) = (N-1)-й бит.** Это самый левый бит, имеющий наибольший вес. Для 2 байт (16 бит) это 15-й бит (т.к. нумерация с 0).

**Краткие вопросы:**
1.  Сколько уникальных значений можно представить, используя 10 бит?
2.  Назовите номера младшего и старшего разрядов для числа, занимающего 4 байта (32 бита).

---

### **Блок 3: Беззнаковые (Unsigned) числа и прямой код**

**Вопросы для самопроверки:**
*   Что такое беззнаковое число?
*   Как называется способ их кодирования?
*   Как найти максимальное значение для беззнакового типа?
*   Как выглядит арифметика для беззнаковых чисел в двоичной системе?

**Что я изучил:**
*   **Беззнаковое число (unsigned)** — целое неотрицательное число (0, 1, 2, 3...).
*   Кодируются в **прямом коде**. Это естественное, понятное представление: двоичный код числа равен его значению.
*   **Диапазон для N бит:** от **0** до **(2^N - 1)**.
    *   Пример для 1 байта (8 бит): от 0 до 255 (2⁸ - 1).
    *   **Максимум** — это когда **все биты равны 1**.
*   **Арифметика** (сложение, инкремент) работает ровно так же, как в десятичной системе, просто непривычно глазу.

**Краткие вопросы:**
1.  Закодируйте беззнаковое число 42 в прямом коде в рамках одного байта.
2.  Чему равно максимальное беззнаковое число для 16 бит (2 байта)? Представьте его в двоичном виде.

---

### **Блок 4: Проблема кодирования отрицательных чисел и неудачное решение (знаковый бит)**

**Вопросы для самопроверки:**
*   Какую простую, но ошибочную идею для кодирования знаковых чисел предлагает интуиция?
*   В чем заключаются две фатальные проблемы этого подхода?
*   Почему наличие двух нулей (+0 и -0) неприемлемо для компьютера?

**Что я изучил:**
*   **Идея:** Выделить старший бит (MSB) под знак (0 = "+", 1 = "-"), а остальные биты — под модуль числа.
*   **Проблема №1 (арифметическая):** Сложение чисел с разными знаками **не дает правильного результата**.
    *   Пример: Код для +1 (`00000001`) + код для -1 (`10000001`) = `10000010` (что по этой же логике равно -2), а должен быть 0.
*   **Проблема №2 (два нуля):** Появляются два кода для нуля: `00000000` (+0) и `10000000` (-0). Это усложняет схемотехнику и логику сравнений.
*   **Вывод:** Эта схема (**прямой код для знаковых чисел**) **не используется** из-за своей неработоспособности.

**Краткие вопросы:**
1.  По "наивной" схеме со знаком, каким был бы 8-битный код для числа -5?
2.  Сложите по правилам двоичной арифметики коды +3 (`00000011`) и -3 (`10000011`) по этой схеме. Что получится и почему это ошибка?

---

### **Блок 5: Ключевое явление — переполнение (Overflow) как основа решения**

**Вопросы для самопроверки:**
*   Что такое "переполнение сверху" для беззнакового байта?
*   Что такое "переполнение снизу" для беззнакового байта?
*   Как визуализировать работу с ограниченной разрядной сеткой?

**Что я изучил:**
*   **Переполнение сверху:** При достижении максимума (все 1) и прибавлении 1, значение сбрасывается в 0.
    *   Пример: `11111111` (255) + 1 = `00000000` (0) в байте (единица "уходит" в несуществующий 9-й разряд).
*   **Переполнение снизу:** При значении 0 и вычитании 1, значение переходит в максимум.
    *   Пример: `00000000` (0) - 1 = `11111111` (255) в байте (как бы "занимаем" у несуществующего старшего разряда).
*   **Модель "кольца" или "циферблата"**: Значения не лежат на прямой, а "зациклены". После 255 идет 0, а перед 0 — 255. Это фундаментально для понимания работы процессора.

**Краткие вопросы:**
1.  Чему будет равно значение однобайтовой беззнаковой переменной после операции: 0 - 1?
2.  Как результат переполнения снизу связан с поиском решения для кодирования отрицательных чисел?

---

### **Блок 6: Гениальное решение — дополнительный код (Two's Complement)**

**Вопросы для самопроверки:**
*   Как, используя переполнение, можно получить код отрицательного числа?
*   В чем заключается формальный алгоритм получения дополнительного кода числа -X?
*   Как связаны коды чисел 128 и -128 в рамках одного байта?
*   Почему эта схема называется "дополнительный код"?

**Что я изучил:**
*   **Ключевая идея:** На числовом кольце **вычитание X** эквивалентно **прибавлению (2^N - X)**. Поэтому можно определить, что код -X = код (2^N - X).
    *   **Мысленный эксперимент:** Код -1 = результат (0 - 1) в байте = `11111111` (255).
*   **Формальный алгоритм** для получения кода отрицательного числа -X:
    1.  Взять прямой код модуля X.
    2.  **Инвертировать** все биты (заменить 0 на 1, 1 на 0). Получится **обратный код**.
    3.  К полученному числу **прибавить 1**.
*   **Важнейший факт:** Для знаковых чисел **старший бит (MSB) = 1** указывает на отрицательное число. Это **получилось как следствие** выбранной схемы, а не было ее исходным условием.
*   **Диапазон для N бит:** от **-(2^(N-1))** до **(2^(N-1) - 1)**.
    *   Пример для 1 байта (8 бит): от -128 до 127. **Обратите внимание на асимметрию!** Отрицательных чисел на одно больше (-128), чем положительных (127).
*   **Положительные числа от 0 до 127** имеют **один и тот же код** в прямой и дополнительной системах. Это позволяет использовать одну арифметику для всех.

**Краткие вопросы:**
1.  Используя алгоритм (инверсия +1), найдите дополнительный код для числа -42 в рамках одного байта.
2.  Объясните, почему в однобайтовом знаковом представлении нет числа +128.

---

### **Блок 7: Практическая проверка. Работа с калькулятором программиста**

**Вопросы для самопроверки:**
*   Как переключить калькулятор Windows в режим "Программист"?
*   Как выбрать размер типа данных (байт, слово и т.д.) в таком калькуляторе?
*   Как проверить, что код -128 действительно равен `10000000`?
*   Почему нельзя ввести число 255 в поле при выбранном типе "байт" и знаковом представлении?

**Что я изучил:**
*   Калькулятор программиста позволяет переключаться между системами счисления (Dec, Bin, Hex, Oct) и **менять размер/тип данных** (Byte, Word, DWord, QWord).
*   **Важно:** При выбранном размере (например, Byte) калькулятор **не даст ввести значение, выходящее за допустимый диапазон** для выбранной интерпретации (знаковой/беззнаковой).
*   Можно наглядно проверить все теоретические выкладки: переполнение, коды отрицательных чисел, соответствие между системами.
*   **Важный навык:** Умение "читать" двоичное представление числа, разбитое на тетрады (группы по 4 бита) или байты.

**Краткие вопросы:**
1.  Используя калькулятор, проверьте, что `11111111` в двоичной системе при типе "Byte" равно 255 (Dec) в беззнаковом представлении и -1 (Dec) в знаковом.
2.  Что произойдет, если в калькуляторе с типом "Byte" попытаться ввести число 300?

---

## **Резюме главы**
*   **Физика:** 0 и 1 — это дискретные уровни напряжения. Промежуточных состояний нет.
*   **Беззнаковые числа:** Кодируются в **прямом коде**. Диапазон: `0 ... (2^N - 1)`.
*   **Проблема знака:** Наивная схема со знаком в старшем бите **не работает** из-за некорректной арифметики и двух нулей.
*   **Переполнение:** Ключевое явление. Значения в ограниченной разрядной сетке "зациклены". `MAX + 1 = MIN`, `MIN - 1 = MAX`.
*   **Дополнительный код:** Умное решение для знаковых чисел. Позволяет использовать **одну схему сложения** для всех чисел.
    *   Алгоритм: `-X = инверсия(X) + 1`.
    *   Диапазон: `-(2^(N-1)) ... (2^(N-1) - 1)`. **Асимметричен!**
    *   Старший бит = 1 для отрицательных чисел (следствие, а не условие).
    *   Коды положительных чисел (0..127) совпадают с прямым кодом.

---

## **Задания для закрепления**

**Задание 1: "Переводчик кодов"**
*   Для однобайтового представления заполните таблицу:

| Десятичное число | Беззнаковое (прямой код) | Знаковое (дополнительный код) |
| :--------------- | :----------------------- | :----------------------------- |
| 0                | `00000000`               | `00000000`                     |
| 1                |                          |                                |
| 127              |                          |                                |
| 255              | `11111111`               | Не существует                  |
| -1               | Не существует            |                                |
| -127             |                          |                                |
| -128             | Не существует            |                                |

**Задание 2: "Анализ сбоя"**
*   В старом оборудовании используется 8-битный знаковый тип для измерения температуры (в условных единицах). Датчик показал значение `10000001`. Какую температуру увидит программа, если интерпретирует байт как:
    а) **Беззнаковое** число?
    б) **Знаковое** число в дополнительном коде?
    Объясните разницу.

**Задание 3: "Предсказание результата"**
*   Программа оперирует **знаковыми однобайтовыми** переменными. Предскажите результат следующих операций (в десятичной системе), учитывая возможность переполнения:
    а) `100 + 30` = ?
    б) `-100 - 30` = ?
    в) `127 + 1` = ?
    г) `-128 - 1` = ?
    Дайте ответ и объясните, что происходит на уровне битов.

**Задание 4: "Конструктор диапазонов"**
*   Составьте аналогичную таблицу диапазонов для 16-битных (2 байта) и 32-битных (4 байта) типов данных.

| Размер (байты) | Беззнаковый диапазон | Знаковый диапазон          |
| :------------- | :------------------- | :------------------------- |
| 1              | 0 ... 255            | -128 ... 127               |
| 2              |                      |                            |
| 4              |                      |                            |

**Задание 5: "Исследование в калькуляторе"**
*   Используя калькулятор программиста:
    1.  Убедитесь, что для типа `Byte` код `10000000` равен 128 (Unsigned Dec) и -128 (Signed Dec).
    2.  Проверьте алгоритм дополнительного кода для числа -42. Запишите шаги.
    3.  Сложите в режиме `Byte` числа 127 и 1 в знаковом представлении. Объясните результат.