# Операторы языка программирования

**Оператор** — это элемент языка, задающий полное описание действия, которое необходимо выполнить. Каждый оператор представляет собой законченную фразу языка программирования и определяет некоторый вполне законченный этап обработки данных. В состав операторов могут входить служебные слова, данные, выражения и другие операторы. В английском языке данное понятие обозначается словом “statement”, означающим также “предложение”.

Каждый оператор в любом языке программирования имеет определенный **синтаксис** и **семантику**. Под _синтаксисом_ оператора понимается система правил (грамматика), определяющая его запись с помощью элементов алфавита данного языка, в который наряду с различными символами входят, например, и служебные слова. Под _семантикой_ оператора понимают его смысл, т.е. те действия, которым соответствует запись того или иного оператора. Например, запись _i := i + 1_ является примером синтаксически корректной записи _оператора присваивания_ в языке Pascal, семантика которого в данном случае такова: извлечь значение ячейки памяти, соответствующей переменной i, сложить его с единицей, результат записать в ту же ячейку памяти.

В большинстве процедурных языков программирования набор операторов практически одинаков и состоит из:
- оператора присваивания,
-  операторов выбора,
- оператор ввода-вывода
- операторов цикла,
- оператора вызова процедуры,
- операторов перехода. 
- пустой (отсутствие действия)
-  составной операторы

. Многие операторы являются способом представления определенных алгоритмических конструкций (см. “_Алгоритмические конструкции_” ![](https://xn----7sbbfb7a7aej.xn--p1ai/informatika_kabinet/programm/img/ref.webp)) в языке программирования. Рассмотрим группы операторов подробнее, используя синтаксис языка Pascal.

###### Оператор присваивания

Присваивание — это действие компьютера, в результате которого переменная получает значение вычисленного выражения (оно помещается в соответствующую переменной ячейку памяти). Для описания такого действия в языках программирования существует **оператор присваивания**.

В общем виде оператор присваивания записывается так:

_<переменная> <знак присваивания> <выражение>_

Например, в языке Pascal в качестве знака присваивания используется комбинация символов :=. В ряде других языков — знак равенства.

Результатом выполнения оператора присваивания является изменение состояния данных: все переменные, отличные от _переменной_, стоящей в левой части оператора присваивания, не меняют своего значения, а указанная _переменная_ получает значение _выражения_, стоящего в правой части оператора присваивания. В большинстве случаев требуется, чтобы тип _выражения_ совпадал с типом _переменной_. Если это не так, то оператор либо считается синтаксически некорректным, либо производится преобразование типа выражения к типу переменной (см. “_Типы данных_” ![](https://xn----7sbbfb7a7aej.xn--p1ai/informatika_kabinet/programm/img/ref.webp)).

###### Операторы ввода-вывода
Взаимодействие программы с внешней средой (пользователем, другими программами, хранимыми данными) является совершенно необходимым. За такой интерфейс в языках программирования отвечают **операторы ввода-вывода** информации. Эти инструкции позволяют ввести в программу данные во время выполнения программы (а не на этапе ее написания) и осуществить вывод рассчитанных данных в понятном человеку виде.

###### Операторы выбора
По-другому эти операторы называют **условными операторами**. Условные операторы используются для программирования алгоритмов, содержащих алгоритмическую конструкцию ветвление.

В языках программирования имеется несколько видов условных операторов. Полный условный оператор соответствует алгоритмической структуре полного ветвления:

![](https://xn----7sbbfb7a7aej.xn--p1ai/informatika_kabinet/programm/img/20.webp)

В языке программирования соответствующий условный оператор имеет вид:

**if** B **then** S1 **else** S2

Если выражение _B_, которое вычисляется в начале выполнения условного оператора, имеет значение “истина”, то будет выполняться оператор _S1_, в противном случае — оператор _S2_. Операторы _S1_ и _S2_ могут быть составными.

Алгоритмическая структура неполного ветвления реализуется с помощью неполного условного оператора, который имеет вид:

**if** B **then** S

Здесь _B_ — логическое выражение, а _S_ — произвольный оператор. Оператор _S_ будет выполняться, если выражение B окажется истинным.

![](https://xn----7sbbfb7a7aej.xn--p1ai/informatika_kabinet/programm/img/21.webp)

Если условный оператор реализует всего две ветви выбора (“да” и “нет”), то с помощью _оператора варианта_ (**case**-оператора) можно запрограммировать многоветвящуюся структуру. Оператор варианта имеет вид:

**case** E **of**

V1: S1;

…

Vn: Sn;

**end**

Выполняется данный оператор так: значение выражения _E_ ищется среди перечисленных в записи оператора значений _V1, V2, …, Vn_, и если такое значение находится, то выполняется соответствующий оператор _S1, S2, …, Sn_.

В разных языках программирования синтаксис и даже семантика перечисленных операторов могут отличаться, но возможности, предоставляемые программисту подобными конструкциями, примерно одинаковы.

**Пример 1.** В статье “_Алгоритмические конструкции_” 2 был приведен пример записи алгоритма решения обобщенного квадратного уравнения с помощью конструкций ветвления. Приведем фрагмент программы на языке Pascal, реализующий этот же алгоритм:

readln(a,b,c);

**if** a = 0 **then**

 **if** b = 0 **then**

 **if** c = 0 **then** writeln('x — любое')

 **else** writeln('нет корней')

 **else** writeln(—c/b)

**else begin**

D := b*b — 4*a*c;

 **if** D < 0 **then** writeln('нет корней')

 **else begin**

      x1 := -b + sqrt(D);

      x2 := -b - sqrt(D);

      writeln(x1:0:2,''', x2:0:2)

 **end**

**end**;

###### Операторы цикла

Операторы цикла реализуют циклические алгоритмические конструкции, они используются для действий, повторяющихся многократно. Во многих языках программирования существуют три вида операторов цикла: “c предусловием”, “c постусловием”, “с параметром”.

Необходимой и достаточной алгоритмической структурой для программирования циклов является цикл “с предусловием”, поэтому его можно назвать основным типом цикла. Оператор цикла с предусловием имеет вид:

**while** B **do** S

Оператор _S_, для многократного выполнения которого создается цикл, называется _телом цикла_. Выполнение оператора цикла сводится к повторному выполнению тела цикла, пока значение логического выражения _B_ истинно (до тех пор, пока оно не станет ложным). Фактически подобные операторы цикла реализуют повторное выполнение условных операторов **if** B **then** S, пока истинно условие _B_.

![](https://xn----7sbbfb7a7aej.xn--p1ai/informatika_kabinet/programm/img/30.webp)

**Пример 2.** Рассмотрим применение такого оператора цикла для подсчета суммы цифр натурального числа _N_:

S := 0;

**while** N > 0 **do begin**

S := S + N **mod** 10;

N := N **div** 10

**end;**

writeln(S);

В цикле с постусловием тело цикла предшествует условию В. В отличие от цикла с предусловием здесь В — это условие окончания цикла. Оператор цикла с постусловием в Паскале имеет вид:

**repeat** S **until** B

При такой организации цикла тело цикла _S_ хотя бы один раз обязательно выполнится.

![](https://xn----7sbbfb7a7aej.xn--p1ai/informatika_kabinet/programm/img/31.webp)

Практически во всех процедурных языках существует _оператор цикла c параметром_. Схематично его можно представить так:

**for <**переменная**>** ![](https://xn----7sbbfb7a7aej.xn--p1ai/informatika_kabinet/programm/img/strelka_left.webp) E1 **to** E2 **step** E3 **do** S

Здесь значение _переменной_ (параметра цикла) меняется от значения выражения E1 до E2 с шагом E3. Для каждого такого значения параметра цикла выполняется оператор S. В языке Pascal понятие шага в описании этого оператора отсутствует, а сам шаг для целочисленного параметра цикла может быть равен либо 1, либо –1. Оператор “цикл с параметром” используется для программирования циклов с заданным числом повторений. Для программирования итерационных циклов (число повторений которых заранее неизвестно) он не годится.

###### Оператор вызова процедуры

В статье “_Подпрограммы_” подробно рассказывается о таком виде подпрограмм, как процедуры. Стандартные подпрограммы языка программирования, которые входят в одну из библиотек подпрограмм, а также пользовательские подпрограммы, описанные внутри данного блока, вызываются с помощью оператора **вызова процедуры**:

<имя процедуры>(E1,E2,…,En)

Здесь E1,E2,…,En — переменные или выражения, представляющие собой _фактические параметры_ обращения к процедуре. Наиболее часто используемыми стандартными процедурами являются процедуры ввода и вывода данных (read и write в Pascal).

Вызов процедуры семантически эквивалентен выполнению блока, описанного в качестве тела процедуры, после передачи в него начальных значений некоторых переменных (параметров-значений) или замены имен некоторых переменных (параметров-переменных) на имена фактических переменных, указанных при вызове процедуры.

**Пример 3.** Пусть у нас описана процедура abc:

**procedure** abc(a,b:integer;**var** c: integer);

**begin**

c := a + b

**end**;

Вызов этой процедуры abc(2,3,x) эквивалентен блоку действий:

a := 2;

b := 3;

x := a + b;

###### Операторы перехода

Наиболее известным в данной группе операторов является оператор безусловного перехода **goto**. Если ко всем или некоторым уже имеющимся операторам программы добавить **метки**, то в программе становится возможным использовать оператор перехода вида:

**goto** <метка>

Метка в данном случае соответствует началу того оператора, с которого должно продолжиться выполнение программы. Такой оператор позволяет записывать в языке программирования алгоритмы, имеющие сколь угодно сложную структуру. Но зачастую использование безусловного перехода неоправданно, т.к. ведет к запутанной, плохо читаемой программе. Практически единственным осмысленным применением оператора **goto** является выход сразу из нескольких вложенных циклов, например, при обработке двухмерных массивов.

**Пример 4.** Пусть нам требуется определить, есть ли в двухмерном массиве a элемент, равный 0:

b := false;

**for** i := 1 **to** N **do**

**for** j := 1 **to** N **do**

**if** a[i,j] = 0 **then begin**

b := true;

**goto** 1

**end;**

1: **if** b **then** write('есть') **else** write('нет');

Программа, разработанная по правилам структурного программирования, не должна содержать операторов безусловного перехода. Приведенную выше программу без использования оператора **goto** можно переписать следующим образом:

b := false;

i := 0;

**while not** b **and** (i < N) **do begin**

i := i + 1

j := 0;

**while not** b **and** (j < N) **do begin**

j := j + 1

**if** a[i,j] = 0 **then** b := true;

**end;**

**end**;

**if** b **then** write('есть') **else** write('нет');

В данном случае структурная программа менее наглядна, чем программа с **goto**.

В языках программирования могут быть определены и другие операторы перехода. Например, в языке Pascal: **break** (досрочное прерывание цикла, переход на оператор, который должен выполняться после завершения цикла), **continue** (досрочное завершение текущей итерации цикла и переход к следующей), **exit** (досрочное прерывание подпрограммы, выход из нее), **halt** (досрочное прерывание программы, переход на ее конец). Аналогичные операторы существуют и в языках С, С++, Java.

###### **Составной оператор**

**Составной оператор** — это группа операторов, заключенных в операторные скобки (в Pascal — **begin** … **end**; в C, C++ — {…}).

Составной оператор введен в языки программирования для облегчения описания конструкций языка. Так, например, в Pascal исполняемая часть каждого блока (программа, процедура, функция) представляет собой один составной оператор. Ровно так же тело любого оператора цикла состоит только из одного оператора, быть может, составного. Альтернативой составному оператору может быть служебное слово, обозначающее окончание того или иного оператора, например, **END IF** в языке Basic.

###### Методические рекомендации

Тема “Операторы языка программирования” обычно изучается только в контексте рассмотрения определенного языка программирования. При ее рассмотрении важно показать связь базовых алгоритмических конструкций и операторов: алгоритмические конструкции записываются в языке программирования с помощью соответствующих операторов. Исключение в некотором смысле составляет последовательная конструкция, она определяет линейный порядок выполнения действий. Действия в строго линейной программе реализуются только операторами присваивания и операторами вызова процедуры.

На начальном этапе обучения программированию у школьников возникает много проблем. Первый психологический барьер им приходится преодолевать при изучении оператора присваивания. Одна из основных задач, которую необходимо решить вместе с учениками, это обмен местами значений двух переменных. Можно предложить школьникам мысленно решить задачу, как поменять местами содержимое двух ящиков, например, письменного стола. Обычно на данном этапе обсуждения ученики догадываются, что для решения задачи необходим третий ящик (переменная). Тем не менее при записи данного алгоритма они часто путают, в какой части оператора присваивания (левой или правой) должна стоять та или иная переменная.

Ошибки в записи арифметических и логических выражений возникают из-за незнания старшинства операций, которые используются в выражении. При этом под операциями понимаются не только арифметические, но и операции сравнения и логические связки, а в языке С и операция присваивания, что весьма непривычно для школьников. Ситуация осложняется тем, что в разных языках программирования одни и те же операции имеют разные относительные приоритеты. Обращать внимание следует и на соответствие типов переменной и выражения в левой и правой частях оператора присваивания (см. “_Типы данных_”).

При освоении операторов выбора полезно предложить школьникам запрограммировать алгоритм, содержащий многоветвящуюся структуру, как с помощью комбинации условных операторов, так и с помощью оператора выбора.

**Пример.** В целочисленную переменную _N_ вводится возраст человека в годах. Напечатать фразу “_Мне K лет_”, заменяя слово _лет_ на _год_ или _года_ в зависимости от числа _K_. Приведем два решения этой задачи:

**var** k: integer;

**begin**

readln(k);

**if** (k **mod** 100) **in** [11..20]

**then** writeln('Мне ',k,' лет')

**else**

**case** k **mod** 10 **of**

0,5..9:writeln('Мне ',k,' лет');

1:writeln('Мне ',k,' год');

2..4:writeln('Мне ',k,' года');

**end**

**end.**

**var** k, n: integer;

**begin**

readln(k); n := k mod 10;

**if** (k **mod** 100) **in** [11..20]

**then** writeln('Мне ',k,' лет') **else**

**if** n = 1 **then** writeln('Мне ',k,' год')

**else**

**if** (n >=) **and** (n <= 4)

**then** writeln('Мне ',k,' года')

**else** writeln('Мне ',k,' лет')

**end**.

При рассмотрении операторов цикла полезно предложить одну и ту же задачу запрограммировать тремя разными способами с использованием трех операторов цикла, и наоборот, по условию задачи научиться определять, какой именно оператор цикла является наиболее подходящим в том или ином случае.

Оператор вызова процедуры только на первый взгляд является простым. Здесь важно объяснить правила передачи параметров в процедуры и функции, различие между параметрами-переменными и параметрами-значениями (в последнем случае мы можем передавать не только имя переменной, но и константу или даже выражение соответствующего типа). Формальные и фактические параметры должны соответствовать по типам, но не по именам, что является далеко не очевидным для учеников.

Изучение условного и особенно составного оператора — хороший повод поговорить с учениками о стиле написания программ. Для языка Pascal существует несколько распространенных способов записи структурированных программ, но все они содержат отступы для размещения вложенных структур. Важны для записи программ и комментарии.