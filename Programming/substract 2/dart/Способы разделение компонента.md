Вы правы, передача контроллера в компонент нарушает принципы разделения ответственности и делает компонент зависимым. Вот несколько способов решить эту проблему:

## Способ 1: Использование GetX/Provider для доступа к контроллеру

```dart
// Вместо передачи контроллера, получаем его через GetX
return ListView.builder(
  itemCount: controller.receipts.length,
  itemBuilder: (context, index) {
    final receipt = controller.receipts[index];
    return ItemReceiptOldWidget(receipt: receipt);
  },
);

class ItemReceiptOldWidget extends StatelessWidget {
  const ItemReceiptOldWidget({
    super.key,
    required this.receipt,
  });

  final Receipt receipt;

  @override
  Widget build(BuildContext context) {
    // Получаем контроллер через GetX
    final controller = Get.find<ReceiptController>();
    
    return ListTile(
      title: Text(receipt.title),
      subtitle: Text(
          '${receipt.amount} руб. • ${receipt.date.toString().substring(0, 10)}'),
      trailing: IconButton(
        icon: const Icon(Icons.delete, color: Colors.red),
        onPressed: () => DialogWidget.showDeleteConfirmationDialog(
          title: 'Подтверждение удаления',
          message: 'Вы уверены, что хотите удалить этот чек?',
          onConfirm: () {
            if (receipt.id != null) {
              controller.deleteReceipt(receipt.id!);
            }
          },
        ),
      ),
      onTap: () {
        Get.toNamed('/receipt/${receipt.id}');
      },
    );
  }
}
```

## Способ 2: Передача только callback функций

```dart
class ItemReceiptOldWidget extends StatelessWidget {
  const ItemReceiptOldWidget({
    super.key,
    required this.receipt,
    required this.onDelete,
    required this.onTap,
  });

  final Receipt receipt;
  final VoidCallback onDelete;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return ListTile(
      title: Text(receipt.title),
      subtitle: Text(
          '${receipt.amount} руб. • ${receipt.date.toString().substring(0, 10)}'),
      trailing: IconButton(
        icon: const Icon(Icons.delete, color: Colors.red),
        onPressed: () => DialogWidget.showDeleteConfirmationDialog(
          title: 'Подтверждение удаления',
          message: 'Вы уверены, что хотите удалить этот чек?',
          onConfirm: onDelete,
        ),
      ),
      onTap: onTap,
    );
  }
}

// Использование:
return ListView.builder(
  itemCount: controller.receipts.length,
  itemBuilder: (context, index) {
    final receipt = controller.receipts[index];
    return ItemReceiptOldWidget(
      receipt: receipt,
      onDelete: () {
        if (receipt.id != null) {
          controller.deleteReceipt(receipt.id!);
        }
      },
      onTap: () {
        Get.toNamed('/receipt/${receipt.id}');
      },
    );
  },
);
```

## Способ 3: Комбинированный подход (рекомендуемый)

```dart
class ItemReceiptOldWidget extends StatelessWidget {
  const ItemReceiptOldWidget({
    super.key,
    required this.receipt,
    this.onDelete,
    this.onTap,
  });

  final Receipt receipt;
  final VoidCallback? onDelete;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    // Если колбэки не переданы, используем GetX контроллер
    final controller = Get.find<ReceiptController>();
    
    return ListTile(
      title: Text(receipt.title),
      subtitle: Text(
          '${receipt.amount} руб. • ${receipt.date.toString().substring(0, 10)}'),
      trailing: IconButton(
        icon: const Icon(Icons.delete, color: Colors.red),
        onPressed: () => DialogWidget.showDeleteConfirmationDialog(
          title: 'Подтверждение удаления',
          message: 'Вы уверены, что хотите удалить этот чек?',
          onConfirm: onDelete ?? () {
            if (receipt.id != null) {
              controller.deleteReceipt(receipt.id!);
            }
          },
        ),
      ),
      onTap: onTap ?? () {
        Get.toNamed('/receipt/${receipt.id}');
      },
    );
  }
}
```

## Способ 4: Создание ViewModel для компонента

```dart
class ItemReceiptViewModel {
  final Receipt receipt;
  final Function(String) onDelete;
  final Function(String) onTap;

  ItemReceiptViewModel({
    required this.receipt,
    required this.onDelete,
    required this.onTap,
  });
}

class ItemReceiptOldWidget extends StatelessWidget {
  const ItemReceiptOldWidget({
    super.key,
    required this.viewModel,
  });

  final ItemReceiptViewModel viewModel;

  @override
  Widget build(BuildContext context) {
    return ListTile(
      title: Text(viewModel.receipt.title),
      subtitle: Text(
          '${viewModel.receipt.amount} руб. • ${viewModel.receipt.date.toString().substring(0, 10)}'),
      trailing: IconButton(
        icon: const Icon(Icons.delete, color: Colors.red),
        onPressed: () => DialogWidget.showDeleteConfirmationDialog(
          title: 'Подтверждение удаления',
          message: 'Вы уверены, что хотите удалить этот чек?',
          onConfirm: () {
            if (viewModel.receipt.id != null) {
              viewModel.onDelete(viewModel.receipt.id!);
            }
          },
        ),
      ),
      onTap: () {
        if (viewModel.receipt.id != null) {
          viewModel.onTap(viewModel.receipt.id!);
        }
      },
    );
  }
}
```

**Рекомендация**: Используйте **Способ 2** (callback функции) для максимальной независимости компонента, либо **Способ 3** для гибкости. Это сделает компонент переиспользуемым и тестируемым.