Отличный вопрос! Вы попали на важный нюанс, который многих сбивает с толку.

**Короткий ответ:** Python остаётся динамически типизированным языком, даже если вы указываете типы. Эти указания — это **аннотации типов (type hints)**, а не строгие объявления, как в C++ или Java. Интерпретатор Python их **игнорирует** во время выполнения, но их могут использовать специальные инструменты.

---

### Что такое "динамическая типизация" в Python?
Это означает, что тип переменной определяется в **момент присваивания значения** и может быть изменён позже.
```python
x = 10      # x сейчас имеет тип int
x = "hello" # а теперь str — и это допустимо
```

### Что такое "сильная типизация"?
Это означает, что язык не выполняет неявные преобразования между несовместимыми типами.
```python
# Python (сильная типизация)
result = "Number: " + 5  # ОШИБКА: TypeError (нужно явно преобразовать str(5))

# JavaScript (слабая типизация)
let result = "Number: " + 5; // Работает: число 5 неявно преобразовано в строку "5"
```

---

### Как указать типы в Python? (Type Hints)

Начиная с Python 3.5+ появились **аннотации типов**. Они нужны для:
1. **Человека:** лучше понимать код.
2. **Инструментов:** статические анализаторы (mypy, pyright, встроенные в IDE) могут находить потенциальные ошибки до запуска кода.

#### Основные способы:

**1. Для переменных и атрибутов класса:**
```python
name: str = "Алексей"
count: int = 0
is_valid: bool = True
price: float = 99.95
```

**2. Для аргументов функций и возвращаемого значения:**
```python
def greet(name: str) -> str:
    return f"Привет, {name}"

def add(a: int, b: int) -> int:
    return a + b
```

**3. Для сложных структур (используя `typing` модуль):**
```python
from typing import List, Dict, Optional, Union, Tuple

# Список целых чисел
numbers: List[int] = [1, 2, 3]

# Словарь: ключ - строка, значение - целое число
grades: Dict[str, int] = {"Анна": 5, "Иван": 4}

# Может быть строкой или None (аналог str | None в Python 3.10+)
middle_name: Optional[str] = None

# Может быть целым числом или строкой (аналог int | str в Python 3.10+)
identifier: Union[int, str] = "abc123"

# Кортеж с фиксированным количеством элементов и типами
coordinate: Tuple[float, float] = (10.5, -20.3)
```

**4. Новый синтаксис (Python 3.10+):**
```python
# Вместо Union[int, str] можно писать так:
x: int | str = 10

# Вместо Optional[str] можно писать так:
y: str | None = None
```

---

### Как это работает на практике?

**Без проверки (как Python работает по умолчанию):**
```python
def add(a: int, b: int) -> int:
    return a + b

# Python выполнит этот код без ошибок!
result = add("Hello, ", "world!")  # Ожидались int, но переданы str
print(result)  # Напечатает: "Hello, world!"
```

**Со статической проверкой (используя mypy):**
1. Установите mypy: `pip install mypy`
2. Проверьте ваш файл: `mypy your_script.py`

Mypy проанализирует код и сообщит об ошибке:
```
error: Argument 1 to "add" has incompatible type "str"; expected "int"
error: Argument 2 to "add" has incompatible type "str"; expected "int"
```

### Важные моменты:

1. **Аннотации — это только подсказки.** Интерпретатор Python их игнорирует при выполнении.
2. **Для принудительной проверки** нужны сторонние инструменты: `mypy`, `pyright`, `pylance` (в VS Code), `pytype`.
3. **Для принудительной проверки в runtime** можно использовать библиотеки типа `pydantic` или `typeguard`.
4. **Для улучшения читаемости** аннотации очень полезны даже без проверки.

### Пример с Pydantic (проверка типов во время выполнения):

```python
from pydantic import BaseModel, ValidationError

class User(BaseModel):
    name: str
    age: int
    email: str | None = None

# Это сработает
user1 = User(name="Иван", age=30)
print(user1.name)  # Иван

# Это вызовет ошибку ValidationError (age не int)
try:
    user2 = User(name="Анна", age="двадцать")
except ValidationError as e:
    print(e)  # Укажет на ошибку типа
```

### Итог:
- **Python динамически типизирован** — типы проверяются во время выполнения, переменные могут менять тип.
- **Python сильно типизирован** — не делает неявные преобразования между строками, числами и т.д.
- **Аннотации типов** — это документация и помощь для статических анализаторов, а не изменение природы языка.
- **Для настоящей статической проверки** нужны дополнительные инструменты.

Поэтому, когда говорят "Python со статической типизацией", имеют в виду "Python с использованием аннотаций типов и статическим анализом", а не изменение самой природы языка.