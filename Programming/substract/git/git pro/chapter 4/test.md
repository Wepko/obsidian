Отлично! Давайте пройдёмся по заданиям и вопросам, чтобы закрепить материал. Я буду отвечать как человек, который изучил главу и применяет знания на практике.

---

### **Ответы на вопросы для повторения (5)**

**1. Какой командой создаётся репозиторий, пригодный для принятия `push` от других пользователей?**
> **Ответ:** `git init --bare <имя-репозитория>.git`. Ключевой флаг `--bare` создаёт "голый" репозиторий, у которого нет рабочей директории. Он содержит только служебную директорию `.git` (само содержимое вынесено на верхний уровень) и предназначен исключительно для приёма изменений (`push`) и их выдачи (`pull`/`fetch`).

**2. Опишите по шагам процесс настройки доступа к серверу по `SSH` без пароля.**
> **Ответ:**
> 1.  **Локально (на вашей машине):** Генерируем пару SSH-ключей, если её ещё нет: `ssh-keygen -t ed25519 -C "your_email@example.com"`. По умолчанию ключи сохранятся в `~/.ssh/id_ed25519` (приватный) и `~/.ssh/id_ed25519.pub` (публичный).
> 2.  **Копируем публичный ключ** на сервер. Самый простой способ — использовать утилиту `ssh-copy-id`: `ssh-copy-id git@server_address`. Если её нет, можно вручную скопировать содержимое `id_ed25519.pub` в файл `~/.ssh/authorized_keys` на сервере.
> 3.  **Проверяем подключение:** `ssh git@server_address`. После этого подключение должно происходить без ввода пароля.

**3. В чём основное ограничение "глупого" (`dumb`) протокола `HTTP`?**
> **Ответ:** "Глупый" HTTP-протокол предоставляет доступ к репозиторию как к набору статических файлов. Он **не поддерживает "умные" (smart) операции Git**, такие как определение общих коммитов при `clone` или `fetch`. Каждая операция требует полной загрузки всех данных, что крайне неэффективно и медленно. Современный "умный" (`smart`) HTTP-протокол (Git HTTP-backend) решает эту проблему, используя специальные CGI-скрипты или серверные модули для эффективного общения между клиентом и сервером.

**4. Какая служба должна быть запущена на сервере для предоставления доступа по протоколу `git://`?**
> **Ответ:** Демон `git daemon`. Он запускается с указанием директории, содержащей голые репозитории, и предоставляет анонимный доступ на чтение по специализированному, быстрому, но незашифрованному протоколу `git://`. Пример команды для запуска: `git daemon --reuseaddr --base-path=/srv/git /srv/git`.

**5. Назовите как минимум две причины, по которым `GitLab` может быть предпочтительнее простой настройки `SSH`-доступа к `bare`-репозиторию для команды из 10 человек.**
> **Ответ:**
> 1.  **Централизованное управление доступом и правами:** GitLab предоставляет веб-интерфейс для управления пользователями, группами и проектами с гибкими уровнями разрешений (гость, репортер, разработчик, мейнтейнер). При чистом SSH-досторе приходится управлять правами через системные учетные записи и `authorized_keys`, что сложнее масштабировать и контролировать.
> 2.  **Инструменты для совместной работы и код-ревью:** GitLab из коробки даёт Pull/Merge Requests, систему Issues, вики, доски Kanban, возможность оставлять комментарии прямо в коде. Это стандартизирует процесс разработки и делает его прозрачным. С голым репозиторием для ревью придётся использовать только почту или внешние инструменты.

---

### **Ответы на задания (6)**

#### **Задание 1 (Базовое): "Свой мини-сервер на SSH"**
> **Ответ (пошаговый отчет):**
> 1.  **На сервере (`server`):**
>     *   `sudo adduser git` (создаём пользователя, можно без пароля для входа по SSH).
>     *   `su - git` (переключаемся на него).
>     *   `mkdir project.git && cd project.git`
>     *   `git init --bare` (создаём голый репозиторий).
> 2.  **Локально (`client`):**
>     *   `ssh-keygen -t ed25519` (если ключей нет).
>     *   `cat ~/.ssh/id_ed25519.pub` (копируем содержимое).
> 3.  **Снова на сервере (`server`):**
>     *   `su - git`
>     *   `mkdir -p ~/.ssh && chmod 700 ~/.ssh`
>     *   `echo "<скопированный_публичный_ключ>" >> ~/.ssh/authorized_keys`
>     *   `chmod 600 ~/.ssh/authorized_keys`
> 4.  **Локально (`client`):**
>     *   `cd /path/to/my/local/project`
>     *   `git init` (если проект новый) и создаём хотя бы один коммит.
>     *   `git remote add origin git@server:/home/git/project.git` (путь может отличаться).
>     *   `git push -u origin main` (или `master`).
>
> **Результат:** Код успешно отправлен на ваш собственный сервер. Теперь любой, чей публичный ключ добавлен в `authorized_keys` пользователя `git`, сможет клонировать (`git clone git@server:...`) и пушить изменения.

#### **Задание 2 (Аналитическое): "Выбор протокола"**
> **Ответ:**
> *   **Ситуация 1 (локальная сеть):** **Локальный протокол (`file://`) или SSH.**
>     *   *Обоснование:* Высокая скорость, простота настройки. Если все разработчики имеют доступ к общей файловой системе (NFS, SMB), `file://` — самый быстрый вариант. Если нет — `SSH` обеспечит безопасность в доверенной сети без лишних сложностей с сертификатами.
> *   **Ситуация 2 (open-source, анонимное чтение):** **Протокол `git://` в сочетании с "умным" HTTPS.**
>     *   *Обоснование:* `git://` — самый быстрый протокол для анонимного клонирования и фетча, что идеально для зеркал. "Умный" HTTPS (`https://`) нужен как резервный вариант для пользователей за строгими корпоративными файрволами, которые могут блокировать нестандартный порт `git://` (9418).
> *   **Ситуация 3 (корпорация, безопасность):** **"Умный" протокол HTTPS (TLS/SSL) с двухфакторной аутентификацией на стороне веб-сервера.**
>     *   *Обоснование:* HTTPS (порт 443) почти гарантированно не блокируется корпоративными прокси. Аутентификация через веб-интерфейс (например, интеграция с LDAP/Active Directory) позволяет легко внедрить 2FA. Весь трафик шифруется. Управление доступом происходит на уровне приложения (GitLab, Gitea, или подобное), а не на уровне системных пользователей.

#### **Задание 3 (Углублённое): "GitLab в песочнице"**
> **Ответ (краткое описание workflow):**
> После установки GitLab (например, через Docker: `docker run -d --name gitlab -p 80:80 gitlab/gitlab-ce:latest`):
>
> 1.  **Создание группы ("Frontend Team") и проекта ("WebApp")** через веб-интерфейс.
> 2.  **Приглашение коллеги:** В настройках проекта → Members → ввести email/логин коллеги, выбрать роль "Developer" (может пушить в ветки, кроме защищённых, создавать MR).
> 3.  **Создание Issue:** "Исправить ошибку входа". Назначаем на себя или коллегу.
> 4.  **Работа над задачей:**
>     *   *Локально:* `git checkout -b fix-login-bug`, вношу правки, коммичу.
>     *   `git push origin fix-login-bug`.
> 5.  **Создание Merge Request (MR):** В GitLab после пуша появляется кнопка "Create Merge Request". В MR привязываю Issue (#1), назначаю ревьюера (коллегу), описываю изменения.
> 6.  **Код-ревью:** Коллега в веб-интерфейсе просматривает код в MR, оставляет комментарии. Я вношу правки, пущу в ту же ветку — MR обновляется автоматически.
> 7.  **Слияние:** После аппрува коллега или я (в зависимости от настроек) нажимаю "Merge". Ветка `fix-login-bug` вливается в `main`. Связанная Issue автоматически закрывается.
>
> **Что покрывает GitLab по сравнению с "голым" Git:**
> | **Аспект workflow** | **Голый Git + SSH** | **GitLab** |
> | :--- | :--- | :--- |
> | **Управление доступом** | Ручное, через `authorized_keys` и права ОС. | Гранулярные роли (Guest → Owner) через веб-интерфейс. |
> | **Планирование работ** | Нет (внешние системы: Trello, Jira). | Встроенная система Issues, milestones, доски. |
> | **Код-ревью** | Через email (`git send-email`) или внешние инструменты. | Встроенный процесс с Merge Requests, inline-комментариями, approval. |
> | **Документация** | Файлы в репозитории (README, wiki в отдельной ветке). | Встроенная Wiki, связанная с проектом. |
> | **CI/CD** | Внешние серверы (Jenkins). | Встроенный GitLab CI/CD с конфигурацией `.gitlab-ci.yml`. |
> | **Прозрачность** | История только через `git log`. | Визуализация коммитов, график веток, активность, аудит. |
>
> **Вывод:** GitLab превращает совместную работу из обмена патчами в **управляемый, прозрачный и стандартизированный процесс**, охватывающий весь жизненный цикл задачи от идеи до развёртывания.

---

Надеюсь, эти развёрнутые ответы помогли не только проверить факты, но и увидеть логику применения инструментов на практике. Глава 4 даёт фундамент для понимания того, как Git "живёт" в команде.