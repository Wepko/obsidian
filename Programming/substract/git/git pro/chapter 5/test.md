Отлично! Вот ответы на вопросы, которые помогут вам проверить и закрепить свои знания.

---

### **Ответы на вопросы для повторения (Факты и практика)**

**1. Перечислите три основные распределённые модели workflow, описанные в начале главы.**

1.  **Централизованная работа (Centralized Workflow):** Один общий удалённый репозиторий. Все разработчики клонируют его, работают в своих локальных копиях и напрямую отправляют (`push`) изменения в общие ветки (обычно `main`). Конфликты решаются на основе "кто первый отправил".
2.  **Диспетчер интеграции (Integration Manager Workflow):** Есть один официальный ("благословлённый") репозиторий. Участники не имеют прав на запись в него. Они создают публичные форки этого репозитория, работают в них, а затем просят мейнтейнера ("диспетчера интеграции") забрать (`pull`) их изменения. Основа модели open-source на платформах вроде GitHub (Pull Request).
3.  **Диктатор и помощники (Dictator and Lieutenants Workflow):** Иерархическая модель для очень больших проектов (например, ядро Linux). Главный мейнтейнер ("диктатор") владеет официальным репозиторием. Группа доверенных "помощников" (lieutenants) управляет определёнными подсистемами. Обычные разработчики отправляют изменения помощникам, те интегрируют их в свои ветки, а затем диктатор собирает ветки помощников в официальный репозиторий.

**2. Как правильно оформить сообщение коммита, чтобы его было легко понять при code review?**

*   **Отделить тему от тела:** Первая строка — краткий заголовок (до 50 символов). Затем пустая строка. Далее — подробное описание.
*   **Заголовок:** Использовать повелительное наклонение ("Add feature", "Fix bug", "Update docs"), а не прошедшее время ("Added").
*   **Тело коммита (опционально, но рекомендуется):** Описать **что** было изменено и, что важнее, **почему**. "Как" видно из самого диффа.
*   **Ссылки на задачи:** Указать номер issue, таска в трекере (например, `Closes #123`, `Refs JIRA-456`).
*   **Пример хорошего сообщения:**
    ```
    Add user authentication via OAuth2

    - Implement Google OAuth2 provider
    - Add new `User` model fields for OAuth data
    - Update login page with "Sign in with Google" button

    This removes the need for maintaining local passwords initially,
    simplifying user onboarding. Migration script for existing users
    will be provided in a follow-up commit.

    Closes #42
    ```

**3. Какие две основные стратегии интеграции чужого кода рассматриваются в разделе "Сопровождение проекта"? В чём их ключевое отличие?**

1.  **Схема с большим количеством слияний (Merge-based workflow).** Все изменения интегрируются путём слияния (`git merge`), создавая в истории коммиты слияния (merge commits). **Плюсы:** Полная история, не переписывается история других людей. **Минусы:** История может стать запутанной.
2.  **Схема с перемещением и отбором (Rebase-and-merge workflow).** Тематические ветки перед интеграцией перебазируются (`git rebase`) на актуальную версию основной ветки, а затем делается fast-forward слияние, либо используется cherry-pick для выборочного применения коммитов. **Плюсы:** Чистая, линейная история. **Минусы:** Переписывается история (опасно для общих веток), может усложнить отладку.

**Ключевое отличие:** В первом случае история сохраняется "как было" со всеми ветвлениями, во втором — история "переписывается", чтобы выглядеть линейной и упорядоченной.

**4. Для чего нужна команда `git request-pull` и в каком сценарии она используется?**

Команда `git request-pull` генерирует готовое текстовое сообщение (для email или описания Pull Request), которое описывает изменения между двумя ветками/коммитами.

**Сценарий:** Вы работаете в собственном публичном репозитории (форке) и хотите уведомить мейнтейнера основного проекта, что ваша работа готова к интеграции. Вы указываете вашу ветку и общую точку расхождения (base commit). Git создаст сводку коммитов и диффов. Это формальный, исторически сложившийся способ запросить "pull" до появления интерактивных Pull Request.

**Пример команды:** `git request-pull origin/main my-feature-branch`

**5. Объясните, как работает механизм `rerere` и в какой ситуации он экономит время.**

**`rerere` (reuse recorded resolution)** — это механизм Git, который **запоминает**, как вы вручную разрешили конфликт слияния или перебазирования.

**Как работает:**
1.  При возникновении конфликта вы разрешаете его вручную (редактируете файлы, `git add`).
2.  При завершении операции (слияния/перебазирования) Git запоминает пару "конфликт -> ваше разрешение" в специальном кеше.
3.  Если в будущем вы столкнётесь с **точно таким же конфликтом** (те же изменения в тех же строках), Git **автоматически** предложит запомненное разрешение.

**Ситуация для экономии времени:**
При работе с **долгоживущей тематической веткой**, которую вы периодически обновляете, перебазируя на актуальную `main`. Если конфликты возникают в одних и тех же местах каждый раз, `rerere` разрешит их автоматически после первого ручного вмешательства, избавляя вас от повторной рутинной работы.

**6. Как с помощью `git shortlog` можно подготовить списки участников для релиз-ноутов?**

Команда `git shortlog` агрегирует коммиты по авторам и выводит список их вкладов за указанный период.

**Полезные форматы для релиз-ноутов:**
*   **Список всех участников релиза:**  
    `git shortlog -s -n v2.0.0..HEAD`  
    `-s` — сводка (только количество коммитов и имя).  
    `-n` — сортировать по количеству коммитов (по убыванию).  
    `v2.0.0..HEAD` — диапазон коммитов с прошлого тега до текущего состояния.
*   **Подробный список с названиями коммитов:**  
    `git shortlog v2.0.0..HEAD`  
    Выведет группировку по автору с заголовками их коммитов.
*   **Только новые участники (дебютанты):**  
    Нужно сравнить списки авторов всех коммитов до и после релиза. Можно скомбинировать с `git log --format="%aN" | sort -u`.

**7. Каковы основные шаги по подготовке стабильной версии (релиза) проекта?**

1.  **Перейти на ветку релиза:** Обычно `git checkout main` (или `stable`, если используется отдельная ветка поддержки).
2.  **Убедиться в чистоте:** Протестировать, что всё собирается и проходит базовые тесты.
3.  **Идентифицировать устоявшиеся версии:** Использовать `git describe` для получения уникального имени на основе последнего тега (например, `v2.1.0-5-gabc1234`, что означает: на 5 коммитов после тега v2.1.0).
4.  **Создать тег:** Создать аннотированный тег для отметки версии. Это момент "заморозки" кода для сборки.  
    `git tag -a v2.1.1 -m "Release version 2.1.1"`
5.  **Обновить метаданные:** Закоммитить в `main` обновлённые номера версий в файлах `package.json`, `CMakeLists.txt`, `README.md` и т.д., чтобы следующий коммит уже вёл к следующей версии (например, `v2.1.2-dev`).
6.  **Сгенерировать changelog:** Использовать `git shortlog`, `git log --oneline --graph` или внешние инструменты для создания списка изменений между тегами.
7.  **Отправить тег на удалённый репозиторий:** `git push origin v2.1.1`
8.  **Собрать дистрибутивы:** Используя код из созданного тега, собрать бинарные пакеты, Docker-образы и т.п.

---

### **Примерные ответы на вопросы для обсуждения (Философия и выбор)**

_Эти ответы не являются единственно верными, а служат основой для дискуссии._

**1. Когда централизованный workflow может быть оправдан?**
*   **Для очень маленьких команд (2-3 человека)** или личных проектов, где процессы минимальны.
*   **На начальном этапе проекта,** чтобы не усложнять процесс.
*   **Для команд, переходящих с SVN или других централизованных систем,** как временная мера для адаптации.
*   **Когда команда обладает очень высоким уровнем дисциплины и синхронизации** (например, пара программистов, работающих бок о бок). Однако при росте команды он быстро становится источником конфликтов и блокировок.

**2. Различие между "диспетчером интеграции" и "тимлидом"?**
*   **Диспетчер интеграции (в open-source)** — это, прежде всего, **арбитр качества и архитектуры**. Он часто лично не знаком с большинством контрибьюторов. Его главная задача — защитить проект от некорректного или не соответствующего видению кода. Его авторитет основан на репутации и доверии сообщества.
*   **Тимлид (в корпорации)** — это, прежде всего, **координатор и наставник своей команды**. Он знает всех участников лично, отвечает за их рост и выполнение плана. Его авторитет основан на должности. Он может использовать модель "диспетчера интеграции" (проверять все пул-реквесты), но его роль шире: планирование, менторство, коммуникация с бизнесом.

**Git-модель отражает это:** В open-source часто используется форк + PR, где право на запись имеют единицы. В корпорациях у всех разработчиков в команде обычно есть права на запись в общий репозиторий, и workflow (например, Git Flow) делегирует больше ответственности каждому.

**3. Почему в open-source проектах предпочитают патчи по email?**
*   **Культурное наследие:** Так работали большие проекты (Linux, Git) до появления GitHub. Это проверенный временем стандарт.
*   **Низкий порог входа для мейнтейнера:** Не нужно управлять доступом к репозиторию, форками, настройками веб-интерфейса. Весь процесс — в почтовом клиенте.
*   **Фокус на качестве вклада:** Патч по почте требует большей дисциплины от контрибьютора (правильное оформление, описание). Это фильтр, отсеивающий несерьёзные или плохо оформленные предложения.
*   **Асинхронность и независимость от платформы:** Не требует аккаунта на GitHub/GitLab, работает через любой email.

**4. Этические и практические границы использования `rebase`.**
**Практическое правило: "Не перебазируйте историю, которая уже была опубликована (отправлена в общий репозиторий) для других."**
*   **Можно и нужно:** Перебазировать свои **локальные, неопубликованные** тематические ветки перед их интеграцией в общую ветку. Это "приведение в порядок" своей работы.
*   **Категорически нельзя:** Перебазировать общие ветки (`main`, `develop`), так как это заставит всех коллег "перемещать" свою работу на новую историю, вызывая массовые конфликты.
*   **Серая зона/Осторожно:** В командах с очень строгой культурой и согласованными процессами можно использовать `rebase` для поддержания линейной истории в главной ветке (например, через "Rebase and Merge" в GitHub), но это требует, чтобы **все** понимали правила и работали только через пул-реквесты из короткоживущих веток.

**5. Модель "диктатора и помощников" устарела?**
**Нет, не устарела, а эволюционировала и нишевилась.**
*   **Принципы живы в корпорациях:** Иерархия "тимлид подсистемы -> главный архитектор" отражает ту же модель. Главный репозиторий защищён, интеграция идёт через пул-реквесты от доверенных лиц.
*   **Для гигантских монолитных проектов (типа ОС или компиляторов)** она по-прежнему актуальна в чистом виде из-за огромного объёма изменений и необходимости жёсткого архитектурного контроля.
*   **Современные платформы (GitHub/GitLab)** автоматизировали и упростили её реализацию через системы protected branches, code owners и многоуровневые code review. Роль "диктатора" часто исполняет автоматическая проверка (CI) плюс группа мейнтейнеров.
*   **В эпоху микросервисов** модель применяется на уровне каждого отдельного сервиса (его репозитория), а не одного монолита.