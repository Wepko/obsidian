Отлично! Вот ответы на вопросы и задания. Сначала сверьтесь со своими решениями, а потом проверьте по этому ключу.

---

## **Ответы на вопросы для повторения**

1.  **`git status`**
2.  **`git restore --staged config.local.json`** (в старых версиях Git: `git reset HEAD config.local.json`)
3.  **`git restore main.py`** (в старых версиях: `git checkout -- main.py`)
4.  **`git log --oneline --graph --all --decorate`** (можно создать алиас для этой команды, например, `git graph`)
5.  **`git remote add upstream https://github.com/original/project.git`**
6.  **`git push origin --tags`**
7.  **`git config --global alias.co 'checkout'`**
8.  **`git rm file.txt`** удаляет файл и сразу индексирует это изменение (готовит его для коммита). **`rm file.txt`** удаляет файл только из рабочей директории, Git видит это как "неотслеживаемое изменение" (untracked) или "удаление", которое нужно добавить в индекс командой `git add` или `git rm`.

---

## **Ответы на практические задания**

### **Задание 1: От инициализации до первого пуша**
*(Предполагается выполнение в терминале)*

```bash
# 1, 2
mkdir my_project && cd my_project
git init

# 3
echo "# Мой проект" > README.md

# 4
git add README.md
git commit -m "Initial commit"

# 5
echo "*.log" > .gitignore
# Добавляем сам .gitignore в репозиторий
git add .gitignore
git commit -m "Add .gitignore"

# 6
touch app.log
# Выполняем git status. Файл app.log не должен отображаться как неотслеживаемый.

# 7 (делается в браузере на GitHub/GitLab) - создаете пустой репо.

# 8
# Копируете URL вашего нового репозитория (например, https://github.com/ваш-логин/my_project.git)
git remote add origin https://github.com/ваш-логин/my_project.git

# 9
git push -u origin main
# Флаг -u устанавливает связь ветки локальной main с удаленной origin/main
```

### **Задание 2: Работа с историей и отменами**
*(Продолжаем в папке `my_project`)*

```bash
# 1
cat > calculator.py << EOF
def add(a, b):
    return a + b
EOF

# 2
git add calculator.py

# 3
cat >> calculator.py << EOF

def subtract(a, b):
    return a - b
EOF

# 4
# a) Разница между рабочей директорией и индексом (то, что НЕ добавлено в stage)
git diff

# b) Разница между индексом и последним коммитом (то, что УЖЕ добавлено в stage)
git diff --staged # или git diff --cached

# 5. Отменяем изменения в рабочем файле (приводим к состоянию индекса)
git restore calculator.py
# Проверяем cat calculator.py - функция subtract исчезла.

# 6. Убираем файл из индекса
git restore --staged calculator.py
# Теперь git status покажет calculator.py как неотслеживаемый.

# 7. Снова добавляем и коммитим
git add calculator.py
git commit -m "Add calculator module"

# 8. Ищем хэш первого коммита
git log --oneline
# Вы увидите что-то вроде:
# abc1234 (HEAD -> main) Add calculator module
# def5678 Add .gitignore
# ghi9012 Initial commit
# Хэш первого коммита - ghi9012 (ваш будет другим).

# 9. Создаем легковесный тег на ТЕКУЩИЙ коммит
git tag v0.1
# Чтобы посмотреть все теги: git tag
```

### **Задание 3: Удаленная работа и теги**

```bash
# 1. Клонирование публичного репозитория (возьмем небольшой пример)
git clone https://github.com/git/git-scm.com.git
cd git-scm.com

# 2. Список удаленных репозиториев
git remote -v
# Вы увидите 'origin', указывающий на клонированный URL.

# 3. Список тегов, отсортированных по версии (если они есть)
git tag -l --sort=-v:refname
# Если в этом репо нет версионных тегов, просто посмотрите список:
git tag -l

# 4. Возвращаемся в свой репозиторий `my_project`
cd ../my_project

# Создаем аннотированный тег на последний коммит
git tag -a v1.0 -m "First stable release"
# Проверим: git show v1.0 (покажет коммит и сообщение тега)

# 5. Отправляем тег на удаленный репозиторий
# Отправка одного тега:
git push origin v1.0
# Или все теги разом (осторожно!):
# git push origin --tags
```

---

## **Краткие ответы для вопросов для обсуждения** (ключевые идеи)

1.  **Преимущества индекса (staging area):**
    *   **Селективность коммита:** Позволяет коммитить только часть изменений в файле (`git add -p`).
    *   **Контроль качества:** Дает "последний шанс" просмотреть (`git diff --staged`) точный снимок перед фиксацией.
    *   **Организация:** Позволяет логически группировать изменения в несколько коммитов, даже если делались они "за один присест".

2.  **`commit -a` vs явный `add`:**
    *   **`git commit -a`** — это ярлык для "проиндексировать изменения всех **отслеживаемых** файлов и сразу скоммитить". Опасность в том, что вы можете нечаянно закоммитить отладочный код или изменения в не тех файлах, так как пропускаете этап селективного `add` и проверки `git diff --staged`.

3.  **Что добавить в `.gitignore`:**
    *   Файлы зависимостей (`node_modules/`, `venv/`, `__pycache__/`, `.env`).
    *   Артефакты сборки (`dist/`, `build/`, `*.class`, `*.exe`).
    *   Файлы IDE (`.idea/`, `.vscode/`, `*.swp`).
    *   Системные файлы (`.DS_Store`, `Thumbs.db`).
    *   Логи и выходные данные приложений (`*.log`, `*.pdf`, `*.zip`).

4.  **`fetch` vs `pull`:**
    *   **`git fetch`** — безопасно забирает все изменения с удаленного репозитория (обновляет `origin/main`), но **не сливает** их с вашей рабочей веткой. Это позволяет изучить изменения перед слиянием.
    *   **`git pull` = `git fetch` + `git merge`**. Может сразу создать конфликт слияния. **`fetch` предпочтительнее**, когда вы хотите контролировать процесс, особенно в сложных ветвлениях.

5.  **Аннотированные vs легковесные теги:**
    *   **Легковесные** — просто указатель на коммит. Для внутренних, временных пометок.
    *   **Аннотированные** — полноценный объект в Git с автором, датой, сообщением. Их можно подписывать (GPG). Используются для **релизов**, так как несут полную информацию и отображаются командами типа `git describe`.

6.  **Стратегия именования коммитов:**
    *   Сообщения вида "фикс" — **плохо**, потому что они не несут контекста. Через месяц ни вы, ни ваши коллеги не поймете, что именно было исправлено.
    *   **Хорошая практика:** Сообщение в повелительном наклонении, с указанием области изменений. Например: `"fix(auth): handle null token in login endpoint"` или `"feat(ui): add dark mode toggle"`.

Отличная работа по проработке главы! Теперь у вас есть прочная основа для перехода к более сложным темам, таким как ветвление (`branching`) и слияние (`merging`).