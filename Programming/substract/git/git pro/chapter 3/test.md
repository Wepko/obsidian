Отлично! Давайте подробно разберём вопросы и задания. Я буду использовать примеры команд, чтобы вы могли их проверить.

---

## **5. Ответы на вопросы для повторения**

### **1. Что физически представляет собой ветка в Git?**
**Ответ:** Ветка в Git — это просто текстовый файл в директории `.git/refs/heads/`, который содержит 40-символьный SHA-1 хеш коммита, на который эта ветка указывает. Например, файл `.git/refs/heads/main` содержит `a1b2c3...`. При создании нового коммита содержимое этого файла обновляется на хеш нового коммита. Это делает ветвление очень быстрой операцией — просто создаётся новый файл-указатель.

### **2. Что произойдёт, если создать коммит, находясь в состоянии `detached HEAD`?**
**Ответ:** Коммит будет создан, но он не будет принадлежать ни одной ветке. Указатель `HEAD` будет указывать напрямую на этот новый коммит. Если вы переключитесь обратно на какую-либо ветку (например, `git checkout main`), этот коммит со временем будет удалён сборщиком мусора Git (обычно через 2 недели), так как на него не будет указывать ни одна ссылка (ветка или тег). Чтобы сохранить такие коммиты, нужно создать на них ветку: `git branch new-branch-name`.

### **3. Объясните разницу между `git merge` и `git rebase` с точки зрения результирующей истории.**
**Ответ:**
- **`git merge`**: Создаёт **новый коммит слияния** (merge commit), который имеет двух родителей. История становится нелинейной, сохраняется полный контекст того, в каких ветках велась разработка. Граф истории выглядит как "развилка" с последующим объединением.
- **`git rebase`**: **Переписывает историю**. Коммиты из текущей ветки "перемещаются" и применяются поверх конца целевой ветки. В результате получается **линейная история**, как если бы работа велась последовательно в одной ветке. Исходные коммиты удаляются (их хеши меняются), создаются новые коммиты с тем же содержанием, но другим родителем.

**Визуально:**
- До: `A--B--C (main) \ D--E (feature)`
- После `merge`: `A--B--C--F (main) / D--E /` (F - merge commit)
- После `rebase feature на main`: `A--B--C--D'--E' (main, feature)`

### **4. Как разрешить конфликт слияния? Перечислите шаги команд.**
**Ответ:**
1.  Git сообщит о конфликте при выполнении `git merge` или `git rebase`.
2.  Используйте `git status` для просмотра файлов с конфликтами (они будут в состоянии "both modified").
3.  Откройте конфликтующие файлы в редакторе. Git помечает конфликтующие участки:
    ```
    <<<<<<< HEAD (или текущая ветка)
    Ваш текущий код
    =======
    Код из сливаемой ветки
    >>>>>>> branch-name
    ```
4.  Вручную отредактируйте файл, оставив нужный код и удалив маркеры конфликта (`<<<<<<<`, `=======`, `>>>>>>>`).
5.  Добавьте разрешённые файлы в индекс: `git add <имя_файла>`.
6.  Завершите процесс слияния: `git commit` (Git предложит сообщение по умолчанию для коммита слияния).

### **5. Что делает команда `git fetch` в отличие от `git pull`?**
**Ответ:**
- **`git fetch [remote-name]`**: Безопасная операция только для **чтения**. Она загружает все изменения из удалённого репозитория (новые коммиты, ветки, теги) и обновляет **удалённые ветки** (например, `origin/main`), но **НЕ изменяет** ваши локальные рабочие ветки (`main`) и рабочую директорию. Это позволяет увидеть, что изменилось на сервере.
- **`git pull [remote-name]`**: Это **композитная команда = `git fetch` + `git merge`**. Она сначала выполняет `fetch`, а затем автоматически **сливает** (merge) соответствующую удалённую ветку в текущую локальную ветку. Это операция **записи**, которая меняет вашу локальную историю и рабочую директорию.

**Безопасная практика:** Часто лучше делать `git fetch`, затем просматривать изменения (`git log origin/main..main`), и только потом решать — делать ли `git merge` или `git rebase`.

### **6. Как безопасно удалить ветку локально и на удалённом сервере (`origin`)?**
**Ответ:**
- **Локальное удаление:** `git branch -d <branch-name>` (с флагом `-d` Git проверит, были ли изменения слиты, чтобы не потерять данные). Для принудительного удаления, даже если изменения не слиты: `git branch -D <branch-name>`.
- **Удаление на удалённом сервере:** `git push origin --delete <branch-name>` или короче: `git push origin :<branch-name>`.

### **7. Что такое «быстрое слияние» (fast-forward) и как его принудительно запретить (`--no-ff`)?**
**Ответ:**
- **Быстрое слияние (fast-forward):** Возможно, когда история целевой ветки (например, `main`) является прямым предком сливаемой ветки (`feature`). В этом случае Git просто перемещает указатель целевой ветки вперёд до конца сливаемой ветки, **не создавая коммит слияния**. История остаётся линейной.
- **Как запретить:** Использовать флаг `--no-ff` (no fast-forward): `git merge --no-ff feature`. Это **всегда создаст коммит слияния**, даже если возможно быстрое слияние. Это полезно для лучшего аудита, чтобы в истории явно сохранился факт слияния тематической ветки.

### **8. Для чего нужен флаг `-u` в команде `git push`?**
**Ответ:** Флаг `-u` (или `--set-upstream`) выполняет две операции:
1.  Отправляет текущую ветку на удалённый сервер (`origin`).
2.  **Устанавливает связь (tracking)** между локальной веткой и удалённой веткой.
После выполнения `git push -u origin feature`, вы можете в дальнейшем использовать короткие команды `git push` и `git pull` без указания репозитория и ветки — Git будет знать, что локальная ветка `feature` отслеживает удалённую `origin/feature`.

---

## **6. Решения и пояснения к практическим заданиям**

### **Задание 1: Мастер ветвления и слияния**

```bash
# 1. Создание и первый коммит
mkdir branch-exercise && cd branch-exercise
git init
echo "Line 1 from main" > main.txt
git add main.txt
git commit -m "Initial commit on main"

# 2. Создание ветки feature и работа в ней
git checkout -b feature  # Создаёт и переключается
echo "Line 2 from feature" >> main.txt
git add main.txt && git commit -m "Add feature line 1"
echo "Line 3 from feature" >> main.txt
git add main.txt && git commit -m "Add feature line 2"

# 3. Возврат на main и внесение конфликтующих изменений
git checkout main
# Редактируем первую строку, чтобы создать конфликт
# Вместо echo можно открыть файл в редакторе и изменить "Line 1 from main" на "Line 1 from main CHANGED"
sed -i 's/Line 1 from main/Line 1 from main CHANGED/' main.txt
git add main.txt && git commit -m "Change line 1 on main"

# 4. Слияние с разрешением конфликта
git merge feature
# Git сообщит: CONFLICT (content): Merge conflict in main.txt
# Открываем main.txt в редакторе. Видим:
# <<<<<<< HEAD
# Line 1 from main CHANGED
# =======
# Line 1 from main
# >>>>>>> feature
# Line 2 from feature
# Line 3 from feature

# Решаем конфликт, например, оставив оба варианта:
# Line 1 from main CHANGED (was: Line 1 from main)
# Line 2 from feature
# Line 3 from feature

# Сохраняем файл, затем:
git add main.txt  # Сообщаем Git, что конфликт разрешён
git commit -m "Merge branch 'feature' with conflict resolution"

# 5. Просмотр графа
git log --graph --oneline --all
# Вы увидите что-то вроде:
# *   abc1234 (HEAD -> main) Merge branch 'feature' with conflict resolution
# |\  
# | * def5678 (feature) Add feature line 2
# | * ghi9012 Add feature line 1
# * | jkl3456 Change line 1 on main
# |/  
# * mno7890 Initial commit on main
```

### **Задание 2: Танцы с удалённым репозиторием**

```bash
# 1. Клонирование (пример с публичным репозиторием)
git clone https://github.com/someuser/somerepo.git remote-exercise
cd remote-exercise

# 2. Создание тематической ветки
git checkout -b my-feature
echo "My contribution" >> README.md
git add README.md && git commit -m "Add my contribution"

# 3. Отправка на удалённый сервер
git push -u origin my-feature

# 4. Симуляция работы коллеги (в другой директории или через веб)
# Допустим, коллега изменил ту же строку README.md на сервере.
# В реальности вы бы увидели это при попытке пуша, но для упражнения:

# 5. Возвращаемся к своей локальной работе
# Сначала обновим main (симулируем, что коллега сделал PR и смержил в main)
git checkout main
git pull origin main  # Получаем изменения коллеги

# Теперь нужно обновить нашу ветку my-feature
git checkout my-feature
# Пробуем rebase на обновлённый main
git rebase origin/main

# Если возник конфликт (скорее всего, если меняли одни и те же строки):
# 1. Разрешаем конфликт в README.md (как в задании 1)
# 2. git add README.md
# 3. git rebase --continue
# 4. Если конфликтов больше нет, rebase завершится.

# После успешного rebase история вашей ветки будет идти после всех коммитов main.
# Можно отправить обновлённую ветку (придётся использовать --force, т.к. история переписана!)
git push origin my-feature --force-with-lease  # Безопаснее чем --force
```

### **Задание 3: Сила перебазирования (Интерактивный режим)**

```bash
# 1. Создание ветки и нескольких коммитов
git checkout -b rebase-demo
echo "Commit 1" > file.txt && git add file.txt && git commit -m "First commit"
echo "Commit 2" >> file.txt && git add file.txt && git commit -m "Second commit"
echo "Commit 3" >> file.txt && git add file.txt && git commit -m "Third commit"
echo "Commit 4" >> file.txt && git add file.txt && git commit -m "Fourth commit"

# 2. Запуск интерактивного rebase для последних 4 коммитов
git rebase -i HEAD~4
# Откроется редактор со списком:
# pick a1b2c3d First commit
# pick e4f5g6h Second commit
# pick i7j8k9l Third commit
# pick m0n1o2p Fourth commit

# Изменяем (в редакторе):
# pick a1b2c3d First commit
# reword e4f5g6h Second commit   # Изменим сообщение
# squash i7j8k9l Third commit     # Объединим с предыдущим
# pick m0n1o2p Fourth commit      # Оставим как есть, но потом переместим

# Сохраняем и закрываем редактор.

# 3.1 Сначала попросит ввести новое сообщение для "Second commit" (теперь с Third).
# Пишем: "Second and third commits combined"
# Сохраняем.

# 3.2 Теперь rebase продолжит выполнение.
# Давайте ещё поменяем порядок: допустим, мы передумали и хотим сделать это.
# Можно отменить rebase и начать заново:
git rebase --abort

# Запускаем снова с другой инструкцией:
git rebase -i HEAD~4
# Меняем порядок строк (коммиты применяются сверху вниз):
# pick a1b2c3d First commit
# fixup i7j8k9l Third commit     # Объединим без сохранения сообщения
# pick e4f5g6h Second commit
# pick m0n1o2p Fourth commit

# После сохранения получится история:
# 1. First commit
# 2. Третий коммит "вшит" в первый (без отдельного сообщения)
# 3. Second commit
# 4. Fourth commit

# 4. Проверяем результат
git log --oneline
# Должно быть 3 коммита (вместо исходных 4), причём в другом порядке.
cat file.txt  # Содержимое должно быть корректным: все строки на месте.
```

**Важное замечание по rebase:** Все эти операции (кроме `--abort`) изменяют историю. Их стоит делать **только на локальных, ещё не отправленных на сервер коммитах**. Если вы уже отправили ветку в общий репозиторий, переписывать её историю (`rebase`, `squash`) опасно — это вызовет проблемы у всех, кто уже склонировал вашу ветку.

---

**Итоговая философская мысль:** Если Глава 2 учила вас *сохранять* историю (неизменяемые снапшоты), то Глава 3 учит вас *управлять* этой историей: создавать параллельные линии разработки (ветки) и затем интегрировать их обратно либо сохраняя всю "правду" о разработке (`merge`), либо создавая "красивое" повествование (`rebase`). Git даёт вам оба инструмента — выбор зависит от принятых в команде соглашений и контекста работы.