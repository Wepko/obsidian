Отличный вопрос! Вы затронули самую суть эффективности Git. Давайте разберем это по шагам.

Вы правы: физически ветка — это просто указатель. Но чтобы понять, как происходит "мгновенное переключение" всей файловой структуры, нужно посмотреть на **три ключевых компонента Git**:

### 1. **Хранилище объектов (`.git/objects/`) — Сердце Git**
Это база данных, где Git хранит **всё** в виде **неизменяемых объектов**. Каждый объект идентифицируется своим SHA-1 хешем. Есть 4 основных типа:
*   **Blob (Binary Large Object):** Хранит **содержимое одного файла**. Не имя, не права доступа, только данные.
    *   Файл `hello.txt` с текстом `"Hello, World!"` → превращается в blob с хешем, например, `8ab686...`.
    *   Если у вас 1000 файлов, в `.git/objects` будет как минимум 1000 blob-ов (плюс их старые версии).
*   **Tree (Дерево):** Хранит **структуру директории**. Это список, связывающий имена файлов и поддиректорий с хешами blob-ов и других tree-ов.
    *   Пример записи: `100644 hello.txt 8ab686...` (права, имя, хеш blob).
    *   Дерево представляет *снимок состояния* вашего проекта на момент коммита.
*   **Commit (Коммит):** Хранит **метаинформацию**: автор, дата, сообщение, и, что самое важное, **хеш tree-а** (который описывает состояние файлов) и **хеш родительского коммита(ов)**.
    *   Это то, на что указывает ветка (указатель в `refs/heads/`).
*   **Tag (Тег):** Аннотированный тег (для простоты, сейчас не важно).

**Ключевой момент:** Все эти объекты **не меняются**. Если вы изменили `hello.txt`, Git создаст **новый blob** с новым хешем. Новое дерево будет ссылаться на этот новый blob, а новый коммит — на новое дерево. Старые объекты остаются в базе навсегда (пока их не очистит сборщик мусора). Это делает Git похожим на **файловую систему, ориентированную на содержимое**.

### 2. **Область подготовленных файлов (Staging Area / Index) — Буфер**
Это специальный файл (обычно `.git/index`), который хранит **предстоящий коммит**. Когда вы делаете `git add`, Git:
1.  Создает blob из содержимого файла и помещает его в хранилище объектов.
2.  Записывает в индекс информацию (хеш blob, имя файла, права доступа).

Индекс — это дерево будущего коммита в "сыром" виде. Команда `git commit` берет этот индекс, создает из него tree-объект, а затем создает commit-объект, ссылающийся на этот tree.

### 3. **Рабочая директория (Working Directory) — То, что вы видите**
Это ваши обычные файлы и папки проекта (кроме `.git`). Здесь вы работаете.

---

### **Теперь главное: как происходит волшебство переключения веток (`git checkout` / `git switch`)?**

**Представьте:** У вас в ветке `main` 1000 файлов. Вы создали ветку `feature` и в ней отредактировали 1 файл и добавили 2 новых. Вы сейчас на ветке `feature`.

Когда вы делаете `git switch main`, Git проделывает следующее:

1.  **Смотрит, куда указывает ветка `main`:** Читает файл `.git/refs/heads/main` и находит хеш последнего коммита в `main` (например, `COMMIT_A`).
2.  **Находит снимок состояния этого коммита:** Извлекает из хранилища объектов commit-объект `COMMIT_A`, находит в нем хеш tree-объекта (`TREE_A`). `TREE_A` — это полная карта состояния всех файлов на момент того коммита.
3.  **Сравнивает целевое состояние (`TREE_A`) с текущим состоянием (вашим индексом и рабочим каталогом на `feature`):**
    *   Вычислит разницу между tree-объектом коммита `feature` и tree-объектом `TREE_A`.
    *   Он видит: "Ага, чтобы перейти к `main`, мне нужно:
        *   Удалить 2 новых файла (которые есть в `feature`, но нет в `main`).
        *   Вернуть 1 отредактированный файл к его старой версии (blob-у, на который ссылается `TREE_A`).
        *   997 остальных файлов не трогать — они идентичны в обоих коммитах.
4.  **Выполняет минимально необходимые изменения:** Git **не перезаписывает все 1000 файлов**. Он точечно и очень быстро:
    *   Удаляет 2 файла из рабочей директории.
    *   Берет из своей базы объектов (`.git/objects/`) старый blob для измененного файла и записывает его на диск, замещая новую версию.
5.  **Обновляет указатели:**
    *   Обновляет `HEAD` (файл `.git/HEAD`), чтобы он теперь указывал на ветку `main` (`ref: refs/heads/main`).
    *   Обновляет индекс (staging area), чтобы он отражал состояние `TREE_A`.

**Всё. Переключение завершено.** Ваша рабочая директория теперь в точности соответствует последнему коммиту в ветке `main`.

### **Аналогия со ссылками на Google Документы**

Представьте, что:
*   **Хранилище объектов Git** — это огромная библиотека всех когда-либо написанных версий всех документов (предложение 1, глава 3, абзац 5...).
*   **Коммит** — это оглавление (Table of Contents) для конкретной версии книги. Оно не содержит сам текст, а только ссылки: "Глава 1 → Документ `abc123`, Глава 2 → Документ `def456`".
*   **Ветка** — это закладка на определенное оглавление.
*   **Рабочая директория** — это ваш стол, куда вы можете положить страницы для чтения и редактирования.

Когда вы "переключаете ветку", вы просто меняете закладку на другое оглавление. Система идет в библиотеку, берет документы, на которые ссылается *новое* оглавление, и кладет их на ваш стол. Документы, которые совпадают в старом и новом оглавлениях, даже не трогаются.

### **Итог**

Git так быстро переключается, потому что он:
1.  **Хранит всё (все версии всех файлов)** в эффективной локальной базе данных (`.git/objects`).
2.  **Не копирует файлы туда-сюда**, а создает из базы данных нужную версию файлов в рабочей директории.
3.  **Работает с указателями (хешами)**, а операции с указателями — это просто запись 40 символов в маленький файл.
4.  **Выполняет только необходимые изменения** в рабочей директории, вычисляя разницу между tree-объектами коммитов.

Поэтому неважно, 10 файлов у вас или 10 000 — стоимость переключения зависит от того, сколько файлов *различается* между ветками, а не от общего их количества. Это и есть гениальность архитектуры Git.