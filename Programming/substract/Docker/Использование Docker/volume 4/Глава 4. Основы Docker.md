Отлично! Вот детально структурированные материалы для самопроверки и закрепления **Главы 4. Основы Docker**.

---

### **Глава 4. Основы Docker**

#### **1. Архитектура Docker**
**Вопросы для самопроверки:**
*   Из каких основных компонентов состоит архитектура Docker (клиент-сервер)?
*   Какова роль Docker Daemon (демона)?
*   Что такое Docker Client и как он взаимодействует с демоном?
*   В чем заключается функция Docker API?

**Что я изучил:**
*   Docker использует архитектуру "клиент-сервер". Docker Client (CLI) отправляет команды Docker Daemon, который выполняет всю тяжелую работу: управление образами, контейнерами, сетями и томами.
*   Клиент и демон могут работать как на одной машине, так и удаленно, общаясь через REST API.
*   Основные составляющие: **Docker CLI** (клиент), **Dockerd** (демон), **Containerd** (runtime), **Runc** (низкоуровневый рантайм).

**Краткие вопросы:**
*   Кто обрабатывает команду `docker run` — CLI или Daemon?

---

#### **2. Базовые технологии**
**Вопросы для самопроверки:**
*   Что такое **namespaces** в контексте Linux и какие из них использует Docker для изоляции контейнеров? (PID, Network, Mount, UTS, IPC, User)
*   Как **cgroups** (control groups) ограничивают ресурсы контейнера (CPU, память, I/O)?
*   Что такое **Union File System** (UnionFS) и какую ключевую роль он играет в работе с Docker-образами и контейнерами?
*   Какие драйверы хранения (storage drivers) вы знаете и в чем их отличие (`overlay2`, `aufs`, `devicemapper`)?

**Что я изучил:**
*   Docker — это не виртуализация, а мощная абстракция над встроенными в Linux технологиями.
*   **Namespaces** обеспечивают изоляцию (процессов, сети, файловой системы и т.д.).
*   **Cgroups** обеспечивают ограничение и учет ресурсов.
*   **UnionFS** позволяет создавать легковесные образы, наслаивая файловые системы (слои).

**Краткие вопросы:**
*   Какая технология отвечает за то, чтобы контейнер не мог "увидеть" процессы хоста?

---

#### **3. Сопровождающие технологии / Хостинг для Docker**
**Вопросы для самопроверки:**
*   В чем разница между Docker Desktop (для macOS/Windows) и Docker Engine (для Linux)?
*   Как Docker Desktop обеспечивает работу Docker на неподдерживающих контейнеры ОС (macOS, Windows)?
*   Какие основные облачные провайдеры предлагают managed-хостинг для Docker (AWS ECS, Google Cloud Run, Azure Container Instances)?

**Что я изучил:**
*   На Linux Docker работает нативно. На macOS и Windows используется легкая виртуальная машина (Linux VM), внутри которой запускается Docker Engine.
*   Существует множество способов запуска Docker: локально, на собственном сервере, в облаке как managed-сервис.

**Краткие вопросы:**
*   Почему для работы Docker на Windows 10 Home требуется Docker Toolbox, а не Docker Desktop?

---

#### **4. Как создаются образы. Контекст. Уровни. Кэширование. Базовые образы.**
**Вопросы для самопроверки:**
*   Что такое **контекст сборки** (build context) и почему весь он (включая ненужные файлы) отправляется демону при `docker build`?
*   Как структурирован Docker-образ (иерархия слоев)? Что представляет собой каждый слой?
*   Как Docker использует кэширование слоев при сборке образа? Какое действие "сломает" кэш для последующих слоев?
*   Что такое **базовый образ** (например, `scratch`, `alpine`, `ubuntu`)? Как выбор базового образа влияет на размер и безопасность конечного образа?
*   Что такое многоступенчатая сборка (multi-stage build) и как она помогает уменьшить итоговый размер образа?

**Что я изучил:**
*   Образ — это неизменяемая многослойная структура. Каждая инструкция в `Dockerfile` создает новый слой.
*   Сборка отправляет весь контекст (текущая директория) демону. Важно использовать `.dockerignore`.
*   Кэш используется до тех пор, пока инструкции и их контекст не изменятся. Изменение одной инструкции инвалидирует кэш для всех последующих.
*   Базовый образ `scratch` — пустой, используется для создания минималистичных образов (например, для Go-приложений).

**Краткие вопросы:**
*   Почему важно помещать редко меняющиеся инструкции (например, `COPY` зависимостей) в начало `Dockerfile`, а часто меняющиеся (например, `COPY` кода приложения) — в конец?

---

#### **5. Инструкции Dockerfile**
**Вопросы для самопроверки:**
*   В чем разница между `CMD` и `ENTRYPOINT`? Приведите примеры их совместного использования.
*   Для чего нужна инструкция `WORKDIR` и чем она лучше последовательности `RUN cd /app && ...`?
*   Как инструкция `COPY` отличается от `ADD`? Почему `COPY` рекомендуется использовать чаще?
*   Как с помощью `ARG` передать переменную во время сборки, а с помощью `ENV` — установить переменную окружения в контейнере?
*   Что делает инструкция `EXPOSE`? Означает ли она, что порт будет автоматически открыт на хосте?

**Что я изучил:**
*   `FROM` — обязательная первая инструкция.
*   `RUN` — выполнение команд в слое при *сборке*.
*   `CMD` и `ENTRYPOINT` — определяют команду по умолчанию при *запуске* контейнера.
*   `EXPOSE` — это документация о том, какие порты использует приложение. Фактическое пробрасывание делается флагом `-p` в `docker run`.

**Краткие вопросы:**
*   Как записать инструкцию, чтобы ваш образ по умолчанию запускал скрипт `start.sh`?

---

#### **6. Установление связи контейнеров с внешним миром. Соединение между контейнерами.**
**Вопросы для самопроверки:**
*   Какие сетевые драйверы Docker существуют по умолчанию (`bridge`, `host`, `none`, `overlay`)?
*   Что такое **bridge-сеть по умолчанию** и как контейнеры в ней видят друг друга?
*   Как пробросить порт из контейнера на хост (`-p 8080:80`)?
*   Как создать пользовательскую сеть и зачем это нужно? (DNS discovery по имени контейнера, лучшая изоляция).
*   Как два контейнера в одной пользовательской сети могут найти друг друга по имени?

**Что я изучил:**
*   По умолчанию контейнеры создаются в виртуальной `bridge`-сети (`docker0`).
*   Флаг `-p` (publish) маппирует порт контейнера на порт хоста.
*   Пользовательские сети (`docker network create mynet`) предоставляют автоматическое разрешение имен (контейнеры могут пинговать друг друга по имени).
*   Сеть `host` убирает сетевую изоляцию, контейнер использует сетевой стек хоста.

**Краткие вопросы:**
*   Какой командой создать сеть `backend` и запустить в ней два контейнера, чтобы они могли общаться по именам `app` и `db`?

---

#### **7. Управление данными с помощью томов и контейнеров данных. Совместное использование данных.**
**Вопросы для самопроверки:**
*   В чем главный недосталок хранения данных внутри контейнера (в его writable слое)?
*   Что такое **том (volume)** Docker? Чем том отличается от **bind mount**?
*   Как создать именованный том и подключить его к контейнеру?
*   Что такое **контейнер данных** (data-only container) и зачем он использовался в прошлом? (Сейчас тома — предпочтительный способ).
*   Как можно передавать данные между хостом и контейнером, и между контейнерами?

**Что я изучил:**
*   Тома (`volumes`) — предпочтительный способ хранения данных, управляемый Docker. Живут вне жизненного цикла контейнера.
*   Bind mounts — привязка конкретной директории хоста в контейнер. Меньше абстракции, больше контроля с хоста.
*   `tmpfs mounts` — данные хранятся только в памяти ОС хоста.
*   Контейнеры данных — устаревший паттерн, когда том монтировался в контейнер без сервиса, а затем использовался другими контейнерами через `--volumes-from`.

**Краткие вопросы:**
*   Как создать том с именем `mydata` и подключить его в контейнер в директорию `/app/data`?

---

#### **8. Часто используемые команды Docker (run, управление, информация, образы, реестр)**
**Вопросы для самопроверки:**
*   Какие ключевые флаги у команды `docker run` (`-d`, `-it`, `-p`, `-v`, `-e`, `--name`, `--network`)?
*   Как просмотреть детальную информацию о контейнере или образе в формате JSON (`docker inspect`)?
*   Как посмотреть логи конкретного контейнера и следить за ними в реальном времени?
*   Как найти все образы, зависящие от конкретного промежуточного образа (показать dangling images)?
*   Как загрузить (`push`) образ в частный реестр, отличный от Docker Hub?

**Что я изучил:**
*   Углубил знания по ключевым командам: `run`, `ps`, `stop`, `rm`, `logs`, `exec`, `inspect`.
*   Управление образами: `images`, `rmi`, `tag`, `build`.
*   Работа с реестром: `login`, `pull`, `push`, `search`.

**Краткие вопросы:**
*   Какой командой узнать IP-адрес, который Docker присвоил работающему контейнеру?

---

#### **9. Резюме**
*   Вы разобрались в фундаментальных технологиях, на которых построен Docker (namespaces, cgroups, UnionFS).
*   Вы понимаете архитектуру "клиент-сервер" и роль каждого компонента.
*   Вы знаете, как устроены образы (слои, кэш, базовые образы) и как эффективно писать `Dockerfile`.
*   Вы освоили ключевые концепции: сеть (драйверы, проброс портов, пользовательские сети) и хранение данных (тома, bind mounts).
*   Вы уверенно владеете основным набором команд Docker CLI для повседневной работы.

---

### **Вопросы для обсуждения после главы**

1.  **Архитектура и безопасность:** Учитывая, что Docker использует общее ядро хоста с контейнерами, какие потенциальные риски безопасности это создает? Как технология namespaces и cgroups помогает их mitigate (снижать), и какие меры безопасности еще нужно принимать?
2.  **Эволюция паттернов:** Паттерн "контейнер данных" (data-only container) сейчас считается устаревшим. Почему именованные тома (`docker volume`) являются более предпочтительным и современным решением для управления состоянием? Какие преимущества они дают?
3.  **Оптимизация сборки:** Ваш коллега жалуется, что сборка его образа после каждого мелкого изменения кода занимает очень много времени, потому что каждый раз заново скачиваются и устанавливаются все зависимости (`npm install` / `pip install`). Как, используя знания о слоях и кэшировании, вы ему поможете переписать `Dockerfile`?
4.  **Сеть на практике:** Когда следует использовать сетевой драйвер `host`, а когда `bridge`? Приведите примеры реальных задач (например, запуск высокопроизводительного веб-сервера nginx vs запуск изолированного микросервиса в составе приложения), где выбор драйвера будет принципиальным.
5.  **Выбор базового образа:** Перед вами стоит задача создать минимальный и безопасный образ для Node.js приложения. Вы видите варианты: `node:latest`, `node:18`, `node:18-slim`, `node:18-alpine`. Какие критерии вы будете учитывать при выборе? Какой образ, скорее всего, выберете и почему?
6.  **Понимание `inspect`:** Команда `docker inspect` выдает огромный JSON с метаданными. Какую практически полезную информацию вы чаще всего извлекаете из этого вывода для отладки или автоматизации?