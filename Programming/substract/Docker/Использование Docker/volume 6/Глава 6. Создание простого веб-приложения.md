Отлично, переходим к **Главе 6. Создание простого веб-приложения**. Вот структурированные материалы для самопроверки.

### **Глава 6. Создание простого веб-приложения**

#### **1. Создание основной веб-страницы**
**Вопросы для самопроверки:**
*   Каков минимальный набор компонентов (файлов) для создания простого статического веб-сайта?
*   Какой официальный образ Docker лучше всего подходит для раздачи статических файлов (HTML, CSS, JS)?
*   Как написать `Dockerfile`, который копирует файлы вашего сайта в правильную директорию внутри образа веб-сервера?
*   Какая стандартная директория внутри популярных веб-образов (например, Nginx, Apache) используется для размещения файлов сайта?
*   Как проверить, что ваш статический сайт в контейнере работает корректно, не открывая браузер (используя CLI)?

**Что я изучил:**
*   Для раздачи статического контента используются легковесные и эффективные веб-серверы, такие как **Nginx** или **Apache (httpd)**. Их официальные образы оптимальны для этой задачи.
*   Стандартная рабочая директория для контента:
    *   Для **Nginx**: `/usr/share/nginx/html`
    *   Для **Apache**: `/usr/local/apache2/htdocs/`
*   `Dockerfile` для такого случая крайне прост: `FROM nginx:alpine`, затем `COPY` файлов сайта в соответствующую директорию.
*   Для проверки работоспособности можно использовать утилиту командной строки, например, `curl localhost:8080`.

**Краткие вопросы:**
*   Напишите минимальный `Dockerfile` для запуска статического сайта (файлы лежат в `./site`) на основе Nginx.

---

#### **2. Использование преимуществ существующих образов**
**Вопросы для самопроверки:**
*   Почему использование официальных образов (`nginx:alpine`, `node:18-slim`) предпочтительнее, чем создание образа "с нуля" (`FROM scratch`) или использования тяжелых базовых образов (`ubuntu:latest`)?
*   В чем заключаются ключевые преимущества образов на базе **Alpine Linux**?
*   Как с помощью `docker inspect` или изучения `Dockerfile` на Docker Hub понять, что находится внутри официального образа?
*   Какие "теги" (`:alpine`, `:slim`, `:-buster`) указывают на оптимизированные версии образов и что они означают?

**Что я изучил:**
*   **Не изобретай велосипед**: Официальные образы поддерживаются сообществом, безопасны, оптимизированы и следуют best practices.
*   **Alpine Linux** — дистрибутив на базе `musl libc` и `BusyBox`. Его главное преимущество — **крайне малый размер** (образы в ~5 раз меньше аналогов на Ubuntu), что ускоряет загрузку, сборку и уменьшает поверхность для атак.
*   Важно выбирать конкретный тег версии (`node:18-alpine`, а не `node:latest`) для воспроизводимости сборок.
*   Можно и нужно изучать `Dockerfile` официальных образов на GitHub или Docker Hub, чтобы понимать их устройство.

**Краткие вопросы:**
*   Какой образ будет меньше и безопаснее: `python:3.11` или `python:3.11-alpine`? Почему?

---

#### **3. Дополнительное кэширование**
**Вопросы для самопроверки:**
*   Как стратегия кэширования слоев Docker может быть использована для ускорения процесса сборки веб-приложения?
*   Почему инструкцию `COPY package.json ./` (или `COPY requirements.txt ./`) следует выполнять ДО инструкции `COPY . ./` (копирования всего кода)?
*   Что такое **dangling images** ("висячие" образы) и как они связаны с кэшем? Как их безопасно удалить?
*   Как многоступенчатые сборки (multi-stage builds) помогают создать минимальный итоговый образ, сохранив преимущества кэширования на этапе сборки?

**Что я изучил:**
*   Ключевой принцип: **Располагай редко меняющиеся инструкции выше, а часто меняющиеся — ниже**.
*   Установка зависимостей (`RUN npm install`) зависит от файла манифеста (`package.json`). Если `package.json` не менялся, Docker использует кэш, даже если изменился исходный код. Это экономит огромное время.
*   Шаблон для Node.js:
    ```dockerfile
    COPY package*.json ./
    RUN npm ci --only=production # Используется кэш, если package.json не менялся
    COPY . ./ # Эта инструкция инвалидирует кэш при любом изменении кода
    ```
*   `docker system prune` удаляет неиспользуемые данные (dangling образа, остановленные контейнеры), освобождая место.

**Краткие вопросы:**
*   Почему сборка происходит долго после каждого изменения в `app.js`, даже если зависимости не менялись? Как исправить `Dockerfile`?

---

#### **4. Микросервисы**
**Вопросы для самопроверки:**
*   Как Docker упрощает разработку и развертывание приложений, построенных по микросервисной архитектуре?
*   Как с помощью Docker Compose можно описать взаимодействие нескольких микросервисов (например, веб-API, сервис аутентификации и база данных)?
*   Какие механизмы Docker используются для изоляции и сетевого взаимодействия микросервисов?
*   В чем преимущество использования микросервисов в контейнерах с точки зрения масштабирования отдельных компонентов приложения?

**Что я изучил:**
*   Docker — идеальная технологическая основа для микросервисов. **Один контейнер = один сервис**.
*   **Docker Compose** позволяет описать весь стек приложения (все микросервисы, их сети, тома) в одном декларативном файле (`docker-compose.yml`).
*   Каждый сервис в Compose работает в изолированном контейнере, но они могут общаться друг с другом по **именам сервисов** через автоматически созданную сеть.
*   Это позволяет разрабатывать, тестировать и масштабировать каждый сервис независимо.

**Краткие вопросы:**
*   В файле `docker-compose.yml` описан сервис `auth-service`. Как к нему обратиться из контейнера другого сервиса `api-service` по сети?

---

#### **5. Резюме**
*   Вы научились создавать эффективные `Dockerfile` для веб-приложений, используя оптимальные официальные образы.
*   Вы поняли важность выбора правильного базового образа (Alpine) для уменьшения размера и повышения безопасности.
*   Вы освоили стратегии кэширования для радикального ускорения процесса сборки при частых изменениях кода.
*   Вы увидели, как Docker и Docker Compose естественным образом ложатся на парадигму микросервисной архитектуры, изолируя сервисы и упрощая их взаимодействие.

---

### **Вопросы для обсуждения после главы**

1.  **Выбор образа: Alpine vs "Полноценный" дистрибутив.** Образы на Alpine Linux имеют малый размер, но иногда могут вызывать проблемы из-за использования `musl libc` вместо `glibc` (например, с некоторыми бинарными зависимостями Python `wheel`). В каких сценариях стоит пожертвовать размером и выбрать более привычный образ на основе Debian (`-slim`, `-buster`)? Приведите примеры проблем и решений.
2.  **Эволюция от монолита к микросервисам.** Представьте, что у вас есть традиционное монолитное веб-приложение в одном контейнере. С какими первыми шагами и сложностями вы столкнетесь, если решите начать разделять его на независимые микросервисы с использованием Docker Compose? (Подумайте о разделении кода, общении между сервисами, общих данных, конфигурации).
3.  **Кэширование зависимостей в CI/CD.** В CI-пайплайне (например, GitLab CI, GitHub Actions) сборка Docker-образа часто запускается "с чистого листа" на каждом коммите. Как в таких условиях эффективно использовать кэш Docker, чтобы не скачивать и не устанавливать зависимости заново каждый раз? Какие техники и флаги (`--cache-from`) можно применить?
4.  **Статика vs Динамика.** В главе рассматривалась раздача статического контента через Nginx. Как изменится подход, если ваше веб-приложение динамическое (например, на Django или Express), но вы все равно хотите использовать Nginx? Какую роль в этом случае будет играть Nginx (реверс-прокси, отдача статики), и как описать эту связку в Docker Compose?