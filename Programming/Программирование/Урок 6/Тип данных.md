https://otus.ru/journal/klassifikaciya-struktur-dannyh/
![[Pasted image 20250731155433.png]]
### Типы данных в Python

Python — это язык с динамической типизацией, что означает, что тип переменной определяется во время выполнения программы, а не во время компиляции. Однако, начиная с Python 3.5, появилась возможность **указывать типы данных явно** с помощью **аннотаций типов (type hints)**. Это не меняет поведение интерпретатора, но помогает инструментам статического анализа (например, `mypy`) находить ошибки.

---

## Основные типы данных в Python

### 1. Встроенные (примитивные) типы:
- `int` — целые числа (`42`, `-10`)
- `float` — числа с плавающей точкой (`3.14`, `-0.001`)
- `str` — строки (`"hello"`, `'world'`)
- `bool` — логический тип (`True`, `False`)
- `NoneType` — тип для `None` (отсутствие значения)

### 2. Коллекции:
- `list` — список (`[1, 2, 3]`)
- `tuple` — кортеж (`(1, "a", True)`)
- `dict` — словарь (`{"key": "value"}`)
- `set` — множество (`{1, 2, 3}`)
- `frozenset` — неизменяемое множество

### 3. Другие типы:
- `bytes` — байтовые строки (`b"hello"`)
- `bytearray` — изменяемая байтовая строка
- `complex` — комплексные числа (`1 + 2j`)

---

## Явное указание типов (Type Hints)

### 1. Аннотации переменных
Можно указывать тип при объявлении переменной:
```python
x: int = 10
name: str = "Alice"
is_active: bool = True
```

### 2. Аннотации функций
Можно указывать типы аргументов и возвращаемого значения:
```python
def greet(name: str) -> str:
    return f"Hello, {name}"

def add(a: int, b: int) -> int:
    return a + b
```

### 3. Аннотации коллекций
Для `list`, `dict`, `set` и других можно уточнять типы элементов:
```python
from typing import List, Dict, Set, Tuple

numbers: List[int] = [1, 2, 3]
person: Dict[str, str] = {"name": "Alice", "age": "30"}  # Обратите внимание, что age здесь str!
unique_ids: Set[int] = {1, 2, 3}
coordinates: Tuple[float, float] = (3.14, 2.71)
```

### 4. `Optional` и `Union`
- `Optional[T]` означает, что значение может быть `T` или `None`.
- `Union[T1, T2]` означает, что значение может быть либо `T1`, либо `T2`.

```python
from typing import Optional, Union

def find_user(user_id: int) -> Optional[str]:
    # Может вернуть имя пользователя или None
    ...

def process_data(data: Union[str, bytes]) -> None:
    # Принимает str или bytes
    ...
```

---

## Конструкция `typing.cast` (Statement для указания типа)

Иногда анализатор типов не может корректно определить тип, и тогда можно использовать `typing.cast`:
```python
from typing import cast

value = some_function()  # Допустим, анализатор не знает тип
value_str = cast(str, value)  # Указываем, что value точно является str
```

**Важно**: `cast` не преобразует тип во время выполнения! Это только подсказка для статического анализатора.

---

## Использование `mypy` для проверки типов

Чтобы проверять аннотации типов, можно использовать `mypy`:
```bash
pip install mypy
mypy your_script.py
```

Пример ошибки:
```python
def add(a: int, b: int) -> int:
    return a + b

result = add(10, "20")  # mypy выдаст ошибку: Argument 2 has incompatible type "str"; expected "int"
```

---

### Выводы:
1. Python поддерживает **аннотации типов**, но они не влияют на выполнение кода.
2. Аннотации помогают находить ошибки с помощью `mypy` и делают код более читаемым.
3. `typing.cast` используется, чтобы явно указать тип, если анализатор не может его вывести.
4. Для сложных структур (`List`, `Dict`, `Optional` и др.) используется модуль `typing`.

Если вам нужно **статическое приведение типов** (как в C++ или Java), то в Python это делается вручную:
```python
x = "123"
x_int = int(x)  # Преобразование строки в int
```