Отличное замечание! Давайте дополним статью, исправив распространённое заблуждение и добавив пример машинного кода.

---

## **1. Как компьютер понимает программу?**  
Компьютер работает **только** на **машинном коде** — наборе бинарных инструкций, которые процессор выполняет напрямую. Например, сложение двух чисел в x86-ассемблере может выглядеть так:

```asm
mov eax, 5   ; Загрузить число 5 в регистр EAX (машинный код: B8 05 00 00 00)
add eax, 3   ; Прибавить 3 (машинный код: 83 C0 03)
```

Здесь:
- `B8 05 00 00 00` — машинный код инструкции `mov eax, 5`  
- `83 C0 03` — машинный код `add eax, 3`

Писать программы в таком виде крайне неудобно, поэтому существуют языки высокого уровня и трансляторы.

---

### **Важное уточнение: как на самом деле работает интерпретатор?**
(С отсылкой к А. Столярову)

**Распространённая ошибка:**  
> "Интерпретатор переводит программу в машинный код построчно и сразу выполняет"

**Почему это неверно:**  
На самом деле, **интерпретатор — это обычная программа**, которая:
1. Читает исходный код (например, Python-скрипт).
2. **Анализирует его структуру** (разбирает на токены, строит синтаксическое дерево).
3. **Выполняет соответствующие действия**, **уже будучи скомпилированной в машинный код**.

**Где здесь машинный код?**  
Сам интерпретатор (например, `python.exe`) — это **скомпилированная программа** на C. Когда вы запускаете скрипт, происходит примерно следующее:

```python
# Ваш script.py
print("Hello")
```

1. Машинный код интерпретатора (`python.exe`) читает файл `script.py`.
2. Видит строку `print("Hello")`.
3. Вызывает **уже скомпилированную** функцию `print()` из стандартной библиотеки Python (которая тоже машинный код!).

**Вывод:**  
Интерпретатор **не генерирует** новый машинный код из вашего скрипта. Он сам является машинным кодом, который "понимает" Python-синтаксис и действует соответственно.

---

### **Сравним подходы корректно:**
| **Действие**          | **Компиляция (C)**               | **Интерпретация (Python)**           |
|-----------------------|----------------------------------|---------------------------------------|
| **Преобразование кода** | Весь код → машинный код заранее  | Нет отдельного машинного кода скрипта |
| **Выполнение**        | Процессор выполняет готовый бинарник | Интерпретатор (машинный код) "разбирает" скрипт и действует |
| **Аналог**            | Переводчик переводит книгу целиком | Актер читает текст с листа и сразу играет |

---

### **Почему это важно?**
1. **Безопасность**: Интерпретатор может динамически проверять код (например, запретить опасные операции).
2. **Гибкость**: Можно менять код "на лету" без перекомпиляции.
3. **Накладные расходы**: Каждый раз анализировать код медленнее, чем выполнять готовый машинный код.

**Пример для Python:**
```python
# Интерпретатор видит это впервые при запуске:
x = 10 + "5"  # TypeError (но только в момент выполнения!)
```
Компилятор C такие ошибки нашёл бы сразу:
```c
int x = 10 + "5"; // Ошибка компиляции: нельзя сложить int и char*
```

---

Теперь статья стала и точнее, и информативнее! Можно добавить эту правку в основной текст.